%% Generated by Sphinx.
\def\sphinxdocclass{jsbook}
\documentclass[letterpaper,10pt,dvipdfmx]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}



\usepackage{times}


\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage[dvipdfm]{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{Text of reconfigurable device Documentation}
\date{2020年05月05日}
\release{0.0.1}
\author{Masayuki Takagiwa}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{リリース}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Contents:


\chapter{はじめに}
\label{\detokenize{01_introduction:id1}}\label{\detokenize{01_introduction::doc}}
本書の目的は VHDL による FPGA (CPLD) への論理回路の実装を一通り体験することです。

到達目標に、「VHDL によるストップウォッチの実装」を設定し、VHDL の説明と実習を行います。

八戸高専の場合、「ディジタル回路」「ディジタル回路」「ディジタル信号処理」と重複するところがあります。それらの授業で学んだことが実習の助けになるでしょう。


\section{受講にあたって}
\label{\detokenize{01_introduction:id2}}
以下の点に注意、協力してください。
\begin{itemize}
\item {} 
お昼休みには基板の電源を切ってください。変な回路を書き込んでおいてデバイスに負荷をかけて壊してしまうことを避けるためです。

\item {} 
演習 = このテキスト通りに入力して動作を確認するもの、課題 = 自力でコードを書いて動作させるもの、としています。

\item {} 
演習、課題でどうしてもツールのエラーが消せないときは呼んでください。

\item {} 
課題はできあがったら基板を持って見せに来てください。達成度を記録します。

\item {} 
成績は、課題の達成度と筆記試験から求めます。

\item {} 
筆記試験は最終日に行い、テキストなどの持ち込みは不可です。

\item {} 
欠席せざるを得ないことがあると思います。そのとき課題は授業中、どうにもならないときは後からおこなってください。

\end{itemize}


\chapter{ストップウォッチについて}
\label{\detokenize{02_stopwatch:id1}}\label{\detokenize{02_stopwatch::doc}}
ディジタルタイプのストップウォッチの例を図に示します。通常「スタート・ストップ」「ラップ・リセット」の２つのボタンと、６桁程度の数字のディスプレイがあります。

「スタート・ストップ」のボタンは、押す毎に「計時」の実行、停止が切り替わります。リセットしない限り、計時は停止した値から再開されます。

「ラップ・リセット」は、停止時に押すと値がクリアされます。計時を行っているときに押すと、通常計時中は変化し続けている数字が停止しますが、計時は続けられています。

実際にはここでは２つの動作があり、「スプリット」では値は引き続きカウントアップしていますが、「ラップ」ではラップボタンで計時は０から再開されます。

数字のディスプレイは通常上位から２桁ずつ、分、秒、1/100 秒のカウントを表示します。


\section{実装目標}
\label{\detokenize{02_stopwatch:id2}}
最低限の目標は以下の機能を VHDL で実装することです。
\begin{description}
\item[{４桁の数字の表示}] \leavevmode
上位２桁は秒、下位２桁は1/100 秒です。

\item[{「スタート・ストップ」スイッチの動作}] \leavevmode
一つのスイッチで行います。

\item[{「ラップ・リセット」スイッチはリセット動作の実装}] \leavevmode
停止中に値のリセットが行えること。

\end{description}

追加目標はラップ機能、スプリット機能の実装となります。


\chapter{FPGA について}
\label{\detokenize{03_fpga:fpga}}\label{\detokenize{03_fpga::doc}}
FPGA はディジタル信号を取り扱う IC、LSI の一種です。

ターゲットの回路が決まっており、予算が十分にあれば、専用の IC 、LSI を製造するのが、デバイス単価、動作周波数、消費電力のいずれも有利です。

それに対し FPGA は内部に組み込む回路を書き換えられることが利点となっています。

「試作・実験」「少量多品種」に向いたデバイスです。

使用例:
\begin{description}
\item[{液晶テレビ}] \leavevmode
FPGA の単価は一般に同じ規模の LSI より高いため、家電製品に FPGA が使われることはありませんが、ある液晶テレビでは一時 FPGA が使われました。
理由は明らかではありませんが、恐らく LSI の設計、製造が間に合わないか、組み込む回路に変更が入る恐れがあったものと考えられます。
LSI は設計や製造に時間がかかり、また内部の回路変更には作り直しが必要ですが、FPGA では直ぐに回路を組み込むことができ、データを入れ替えるだけで変更も可能です。

\item[{携帯電話と基地局の試作機}] \leavevmode
携帯電話や基地局は世界的な規格に則って作られますが、規格が固まってから作っていると発売が遅くなってしまいます。
規格が固まる前にシステムを作ってしまい、規格変更に合わせてあとから回路が変更できるよう、FPGA が大量に使われます。
規格や回路が固まったら、必要に応じて LSI に移行します。

\item[{株・為替自動取引}] \leavevmode
コンピュータによる高頻度取引では１秒以下の周期で株価、為替の情報を監視し、自身に有利なタイミングで売買を行います。
ソフトウェアだけでの処理は遅いと考えられており、FPGA による処理が併用されます。
処理のアルゴリズムは使用者毎に異なるため、LSI 化はできず、FPGA が使用されます。

\end{description}

\begin{sphinxadmonition}{note}{注釈:}
実際にこの授業で使用するデバイスは「PLD」と呼ばれます。PLD は Programmable Logic Device の略です。プログラム可能な論理デバイス、となります。

対して FPGA は Field Programmable Gate Array の略です。現場 (Field) でプログラム可能なゲート (論理) の集合、となります。

できることはほぼ同じですが、以下のような特徴で分けています。

CPLD
\begin{itemize}
\item {} 
フラッシュメモリを内蔵し、電源を入れるとすぐ使える。

\item {} 
回路規模は小さめ。

\item {} 
基本的に論理回路しか入ってない。

\item {} 
動作速度が比較的高い。

\item {} 
構造上、XOR が少し苦手。

\end{itemize}

FPGA
\begin{itemize}
\item {} 
動作のプログラムは揮発性のメモリに格納されるので、電源を切ると内容が失われる。そのため別途フラッシュメモリが必要。

\item {} 
回路規模はかなり大きい。

\item {} 
高機能 (乗算用ハードウェアが入っていたり、メモリが入っていたりする) 。

\item {} 
動作速度は今ではだいぶ高くなってきた。

\end{itemize}

いずれも D フリップフロップと組み合わせ回路がセットになっており、その入力をプログラムするような形です。このセットがデバイスの中に多数組み込まれ、相互に接続できるよう配線とスイッチも同様に多数用意されます。

CPLD と FPGA の間の大きな違いは組み合わせ回路の構成です。CPLD は大量の AND と多入力 OR を組み合わせていますが (実際には NOT も入ります) 、FPGA は AND 、OR に縛られない LUT (LookUp Table) を使用します。たとえば４入力の AND 、４入力の OR に限らず、\textbackslash{}"4\textbackslash{}" 等の任意の数値と一致したときに H を出力する、というようなことも簡単にできるよう、より柔軟な構造になっています。
\end{sphinxadmonition}


\section{HDL}
\label{\detokenize{03_fpga:hdl}}
ディジタル回路を組み込んだ IC や LSI の開発では、初期には AND 、OR 、NOT 、フリップフロップを CAD 上で回路図のように配置して接続していました。

こういった CAD は、IC 、LSI メーカ毎に異なるため、たとえば完成したデータを違う LSI メーカで製造しなければいけなくなったとき、互換性が無いため入力＆確認し直しが必要になっていました。

こういった状況を避けるために、IC 、LSI の開発も、ソフトウェアのようにテキストで行おうという動きがでてきました。このジャンルの言語は HDL  (Hardware Description Language) と呼ばれます。

ソフトウェアと同様、HDL も様々なものが開発されましたが、現在の主流は VerilogHDL と VHDL です。

VerilogHDL、VHDL は FPGA だけでなく、IC、LSI の開発にも利用されます。


\section{VerilogHDL と VHDL}
\label{\detokenize{03_fpga:veriloghdl-vhdl}}
各言語の特徴を以下に示します (筆者の独断と偏見を含む)

VerilogHDL
\begin{itemize}
\item {} 
民間主導\sphinxhyphen{} ツールメーカが開発した。

\item {} 
比較的便利な記述ができるようになっている。

\item {} 
文法上記述ミスが許容される傾向がある＝ デバッグ時に大変なことが多い。

\item {} 
日本でのシェアは、こちらがかすかに多いかもしれない。

\item {} 
C 言語に近い、と評されることがあるものの、上記のような動きがあることから、むしろ BASIC の方が近いと感じる。

\item {} 
無料のシミュレータがあるため、特に趣味の範囲での人気は VHDL より高い模様。

\end{itemize}

VHDL
\begin{itemize}
\item {} 
米国国防省主導\sphinxhyphen{} ソフトウェアのプログラミング言語をベースに策定

\item {} 
融通が利かず、あまり高機能でない。コード量は多くなる傾向かもしれない。

\item {} 
海外でのシェアは、こちらがかすかに多いかもしれない。

\item {} 
BASIC ににたキーワードもあるものの、文法エラーの検出の強さは C 言語に近い。

\end{itemize}


\section{高位合成}
\label{\detokenize{03_fpga:id1}}
HDL は一般にクロックや信号の衝突などソフトウェアとは異なる考え方が必要になります。それだけ、HDL のプログラマはソフトウェアのプログラマに比べ人口が少ないです。

それでも FPGA に魅力を感じている人々が長年ツールを開発し続け、2014年頃からそれが安価に入手できるようになりました。

Xilinx 社は HLS という名前で、C 言語での FPGA 開発ができるようになっています。

Intel 社 ( Altera 社を買収 )、Xilinx 社 %
\begin{footnote}[1]\sphinxAtStartFootnote
FPGA メーカーは現在はあまり多くなく、Intel 社と Xilinx 社でほぼ寡占、Lattice 社が単独3位のようなポジションで、あとは小規模なメーカーがいくつか。
%
\end{footnote} とも OpenCL 対応のデータ処理向けの開発環境をそろえています。

より高レベル (ハードウェアから遠いという意味で) な言語によるアプローチもあり、これらは高位合成と呼ばれています。

現在は Java 、Python などの言語での FPGA 開発が可能になっています。

ただし FPGA に組み込む回路全てをこれらの言語だけで開発できないパターンもあり、そういった箇所には引き続き VerilogHDL、VHDL が使われます。


\chapter{VHDL}
\label{\detokenize{04_vhdl:vhdl}}\label{\detokenize{04_vhdl::doc}}

\section{基本形}
\label{\detokenize{04_vhdl:id1}}
VHDL のソースコードは、基本的には以下のような形です。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure01}.eps}
\end{figure}

これがテンプレートとなります。コードを記述するときは、この中の x、y、３つの枠の中を、目的に合わせて書き換えます。

ここで x は entity 名、y は architecture 名です。ポート宣言はこの entity が外部とやりとりする信号 (たとえば実際のデバイスのピン) を宣言します。

entity 名はこの回路に対する自由な名前 (たとえば機能から名付けるなど) 、architecture 名はどの entity に対しても同じ「rtl」という名前をつけておけば通常問題ありません。

これらは以下のようなイメージになります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure02}.eps}
\end{figure}

ファイルにはいくつかの entity 、architecture を含めることができますが、この実習では一つのファイルに一つの entity 、architecture を保存し、ファイル名は entity 名に合わせて設定してください。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure03}.eps}
\end{figure}


\subsection{解説}
\label{\detokenize{04_vhdl:id2}}

\subsubsection{entity とその周辺}
\label{\detokenize{04_vhdl:entity}}
entity と architecture はいずれもそれ単体では何もできません。わざわざ分かれているところから想像できるとおり、同じ entity に対して異なる architecture を適用させることもできますが、この授業では扱いません。

また entity 、architecture が動作するためには、entity の前にある４行のライブラリ宣言が必要です。

ここでは ieee の 1164 、arith 、unsigned を呼び出しています。この授業ではこの組み合わせを使用しますので、この４行のライブラリ宣言もそのまま使用します。

C 言語のインクルードファイルの宣言などと異なり、ファイルに複数の entity 、architecture を記述する場合、ライブラリ宣言は entity 毎に宣言し直す必要があります。４個の entity を記述していれば、その都度、合計４回のライブラリ宣言が必要です。


\subsection{ファイルとの関係}
\label{\detokenize{04_vhdl:id3}}
一般にファイル名と entity 名をそろえ、拡張子は「.vhd」とします。

一つのファイルに複数の entity 、architecture を記述することもできますが、その際はそれに対応した use 、library の宣言も必要です。

この授業では、一つのファイルに一つの entity 、architecture とするのがよいでしょう。

またライブラリのうち unsigned は名前から想像できるとおり符号なしの演算を行います。符号付きの演算を行いたい場合は代わりに signed を呼び出します。一つの entity 、architecture 内では混在はできません。


\section{信号の種類}
\label{\detokenize{04_vhdl:id4}}
信号は、ソフトウェアで言う変数と同様のイメージから考えてください。

たとえば C 言語であれば char 、int 、float 等があるように、VHDL でもライブラリを読み込むことで以下のような信号が扱えます。


\subsection{std\_logic}
\label{\detokenize{04_vhdl:std-logic}}
1bit の信号。通常使用する値は 0、1、Z です。

直値を扱う場合、1bit 分ずつシングルクオートで括ります。

0、1 は信号の L レベル、 H レベルに対応します。

Z は「ハイインピーダンス」で、その信号が無い、何もつながっていない状態を作ります。この授業の範囲では使いません。

例

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZsq{}} \PYG{l+m+mi}{0} \PYG{p}{\PYGZsq{}} \PYG{p}{,} \PYG{p}{\PYGZsq{}} \PYG{l+m+mi}{1} \PYG{p}{\PYGZsq{}} \PYG{p}{,} \PYG{n+na}{\PYGZsq{}Z} \PYG{p}{\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{std\_logic\_vector}
\label{\detokenize{04_vhdl:std-logic-vector}}
std\_logic を束ねたもので、任意のビット数を扱うことができます。

各ビットに代入できる値は std\_logic と同じです。

束ねるビット数は宣言時に決めておきます。たとえば１０進数で０～１００までを扱うには 7bit 必要ですので、７本の std\_logic を束ねるため、以下のような形式になります。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{6} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

この場合、MSB %
\begin{footnote}[1]\sphinxAtStartFootnote
変化することにより全体の値が大きく変化するビット
%
\end{footnote} が bit 6 、LSB %
\begin{footnote}[2]\sphinxAtStartFootnote
変化から値全体の変化が一番小さいビット
%
\end{footnote} が bit 0 という宣言になります。ここに代入する値は、たとえば１０進数の１０であれば

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}0001010\PYGZdq{}}
\end{sphinxVerbatim}

というふうにダブルクオーテーションで括ります。左が bit6 、右が bit0 です。代入する値は、代入先の信号とビット幅が一致している必要があります %
\begin{footnote}[3]\sphinxAtStartFootnote
ビット幅が一致していなくてもツール上エラーにならない場合があり、発見しづらいバグになりやすいです。
%
\end{footnote} 。

例

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}010101010\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}00Z00Z\PYGZdq{}}
\end{sphinxVerbatim}

括弧 () でビット番号を指定することで、std\_logic として 1bit 抜き出して扱うことができます。

\begin{sphinxadmonition}{note}{注釈:}
std\_logic\_vector(0 to 6) という宣言の仕方もありますが、ソースやプロジェクトの中で混在させるのはバグのもとになるので通常はどちらかに統一します。

この授業では downto に統一します。

図の上を MSB、下を LSB とした場合、downto と to の関係は次の図のようになります。

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{figure04}.eps}
\end{figure}
\end{sphinxadmonition}


\subsection{integer}
\label{\detokenize{04_vhdl:integer}}
10 進数を直接扱います。bit は意識しません。std\_logic や std\_logic\_vector とは直接接続することはできません。


\section{ポート宣言}
\label{\detokenize{04_vhdl:id8}}
ポート宣言では、この entity  (回路ブロック) が外部とやりとりする信号を定義します。

複数の信号を定義でき、それぞれ以下のような形です。

ポート名: 方向信号型

定義の区切りにセミコロンが必要です。定義の終わりを示すものでは無いので、最後の定義ではセミコロンは書きません。

例

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extsignal1} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{n}{extsignal2} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{extsignal3} \PYG{o}{:} \PYG{k}{inout} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{n}{extsignal4} \PYG{o}{:} \PYG{k}{buffer} \PYG{k+kt}{std\PYGZus{}logic}
\end{sphinxVerbatim}

ポート名は任意の名前をつけ、architecture 内からその信号にアクセスできます。

方向については上記の４パターンがあります。
\begin{description}
\item[{in}] \leavevmode
この entity への入力です。architecture 内では読むことしかできません。

\item[{out}] \leavevmode
この entity からの出力です。architecture 内で書き込むことしかできません。

\item[{inout}] \leavevmode
入出力両方ができます。architecture 内では読み書きができますが、信号が衝突すると電気的に短絡 (ショート) となるため、エラーとなります。エラーにならない対応はこの授業では扱いません。

\item[{buffer}] \leavevmode
この entity からの出力です。out との違いは信号の再利用ができることですが、制約もあるので使うのは避けた方がよいでしょう。

\end{description}

それぞれのイメージを図に示します。読み書きは他の signal へ、または signal からの「代入」と読み替えてもよいでしょう。

buffer と inout はこの授業では使用しません。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure05}.eps}
\end{figure}


\section{シグナル宣言}
\label{\detokenize{04_vhdl:id9}}
アーキテクチャの中で使用する信号を宣言します。アーキテクチャの記述の中で、begin の前に行います (begin より後には宣言できません) 。

例

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{signal} \PYG{n}{intsignal1} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{signal} \PYG{n}{intsignal2} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{signal} \PYG{n}{intsignal3} \PYG{o}{:} \PYG{k+kt}{integer}\PYG{p}{;}
\PYG{k}{signal} \PYG{n}{intsignal4} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\end{sphinxVerbatim}

"signal" キーワードの後に、ポート宣言と同様に任意の名前をつけます。信号の種類もポート宣言と同様です。

アーキテクチャ内部でのみ使用するので、方向は記述しません。

また全ての宣言で末尾はセミコロンで閉じます。


\section{値の代入}
\label{\detokenize{04_vhdl:id10}}
代入は "\textless{}=" で行います。

例 (１)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{intsignal1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
\PYG{n}{intsignal4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{intsignal1}\PYG{p}{;}
\PYG{n}{intsignal2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{;}
\PYG{n}{intsignal3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}

std\_logic\_vector の場合は値の扱い方にバリエーションがあるのでここで解説します。

合計したビット数が代入先の信号に一致していれば、＆で結合できます。

括弧でビットを指定すれば、std\_logic を代入したり、参照したりできます。


\section{もう一つの信号 variable と代入}
\label{\detokenize{04_vhdl:variable}}
VHDL には port 、signal の他にもう一つ、variable という信号のタイプがあります。

variable は後述する process 文の中でのみ使用でき、信号のタイプは他と同様 std\_logic 等を使うことができます。

代入には := を使います。

variable はこの授業では扱いません。


\chapter{演習}
\label{\detokenize{05_try:id1}}\label{\detokenize{05_try::doc}}

\section{注意事項}
\label{\detokenize{05_try:id2}}\begin{itemize}
\item {} 
開発環境 Quatus II のプロジェクトは、実習項目毎に作り直してください。流用するとトラブルの元になります。

\item {} 
Quatus II の中で日本語を入力するのは避けましょう。こちらもトラブルの元になります。

\end{itemize}


\section{論理演算}
\label{\detokenize{05_try:id3}}

\subsection{演習}
\label{\detokenize{05_try:id4}}
プロジェクト名 vhdl01

スイッチ入力に対して論理演算を行い、結果を LED に出力します。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl01} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{sw1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led2} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led3} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led4} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led5} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl01}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl01} \PYG{k}{is}
\PYG{k}{begin}
  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw1}\PYG{p}{;}
  \PYG{n}{led2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw2}\PYG{p}{;}
  \PYG{n}{led3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw1} \PYG{k}{and} \PYG{n}{sw2}\PYG{p}{;}
  \PYG{n}{led4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw1} \PYG{k}{or} \PYG{n}{sw2}\PYG{p}{;}
  \PYG{n}{led5} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw1}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

このコードで出力される回路は図のようなものになります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure06}.eps}
\end{figure}

スイッチは基板奥の方 (７セグ LED 側) に倒すと H 、手前で L のレベルになります。
LED に対してはデバイスから H を与えると消灯、L を与えると点灯します。
たとえば led1 はスイッチ１番を奥に倒すと消灯、手前に倒すと点灯します。led5 は逆の点灯の仕方になります。

\begin{sphinxadmonition}{note}{注釈:}
この授業で使っている基板は2つのリビジョンがあり、リビジョン間でスイッチの極性が異なります。

期待した動きをしないときは、これが原因の場合があります。cd
\end{sphinxadmonition}


\section{数値演算}
\label{\detokenize{05_try:id5}}

\subsection{演習}
\label{\detokenize{05_try:id6}}
プロジェクト名 vhdl02

スイッチ入力に対して数値演算を行い、LED に表示します。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl02} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{sw1}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw3}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw4}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw5}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw6}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw7}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw8}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

    \PYG{n}{led1}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led2}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led3}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led4}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led5}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led6}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led7}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led8}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

    \PYG{n}{sled1a} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1b} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1c} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1d} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1e} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1f} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1g} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2a} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2b} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2c} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2d} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2e} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2f} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled2g} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl02}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl02} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw1} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw2} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw3} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw4} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw5} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw6} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw7} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s\PYGZus{}sw8} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{sw} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{8} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{add} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{sub} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{led71} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{6} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{led72} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{6} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} fixed polarity}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} revision 2}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw1 \PYGZlt{}= sw1;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw2 \PYGZlt{}= sw2;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw3 \PYGZlt{}= sw3;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw4 \PYGZlt{}= sw4;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw5 \PYGZlt{}= sw5;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw6 \PYGZlt{}= sw6;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw7 \PYGZlt{}= sw7;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}sw8 \PYGZlt{}= sw8;}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} revision 1 (no revision)}
  \PYG{n}{s\PYGZus{}sw1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw1}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw2}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw3}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw4}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw5} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw5}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw6} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw6}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw7} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw7}\PYG{p}{;}
  \PYG{n}{s\PYGZus{}sw8} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sw8}\PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} left 4 switches \PYGZam{} right 4 switches}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} left switch is MSB}
  \PYG{n}{sw} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s\PYGZus{}sw1} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw2} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw3} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw4} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw5} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw6} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw7} \PYG{o}{\PYGZam{}} \PYG{n}{s\PYGZus{}sw8}\PYG{p}{;}

  \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw}\PYG{p}{(}\PYG{l+m+mi}{8} \PYG{k}{downto} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{sw}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw}\PYG{p}{(}\PYG{l+m+mi}{8} \PYG{k}{downto} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{sw}\PYG{p}{(}\PYG{l+m+mi}{4} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} make 7 seg LED bit map}
  \PYG{n}{led71} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1001\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1000\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0111\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0110\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0010010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0101\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0011001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0100\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0110000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0011\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0100100\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0001\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{add} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000110\PYGZdq{}} \PYG{p}{;}
  \PYG{n}{led72} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1001\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1000\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0111\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0110\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0010010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0101\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0011001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0100\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0110000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0011\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0100100\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0001\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sub} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000110\PYGZdq{}} \PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} map to pin}
  \PYG{n}{sled1a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1e} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1f} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1g} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led71}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2e} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2f} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled2g} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{led72}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} debug}
  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led5} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led6} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led7} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led8} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{sub}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

スイッチの上位 (基板上左側) ４ビットと下位 (右側) ４ビットの演算を行います。LED の上位に加算の結果、下位に減算の結果が２進数で表示されます。

たとえばスイッチを８から１まで、10100001  (1=ON, 0=OFF) とした場合、結果 (= LED の点灯パターン) は 10111001 となります。

また７セグ LED にも結果を表示します。７セグ LED は 0 ～ 9 までの表示を行います。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure07}.eps}
\end{figure}

\begin{sphinxadmonition}{note}{注釈:}
符号無し 4 ビット演算です。

このコードでは、10 以上の数値 ( 具体的には 0 ～ 9 以外 ) は ７セグ LED の表示は E になります。
\end{sphinxadmonition}


\section{条件分岐 when ～ else ～}
\label{\detokenize{05_try:when-else}}

\subsection{演習}
\label{\detokenize{05_try:id7}}
プロジェクト名 vhdl03

条件分岐の書き方の一つ、when ～ else ～ の例です。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl03} \PYG{k}{is}
  \PYG{k}{port}\PYG{p}{(}
    \PYG{n}{sw1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw8}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl03}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl03} \PYG{k}{is}
\PYG{k}{begin}
  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw2} \PYG{k}{when} \PYG{p}{(}\PYG{n}{sw8} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{n}{sw1}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

sw8 を H レベルにしておくと、LED1 は sw2 の操作に従って点灯します。

sw8 が L レベルの場合は、LED1 は sw1 の操作に従って点灯します。

このコードから生成される回路のイメージは次の図の通りです。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure08}.eps}
\end{figure}

この記述ではいくつでも分岐させることができます。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ans} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x1} \PYG{k}{when} \PYG{p}{(}\PYG{n}{y1} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{else} \PYG{n}{x2} \PYG{k}{when} \PYG{p}{(}\PYG{n}{y2} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{else} \PYG{n}{x3} \PYG{k}{when} \PYG{p}{(}\PYG{n}{y3} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{else} \PYG{n}{x4} \PYG{k}{when} \PYG{p}{(}\PYG{n}{y4} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}
  \PYG{k}{else} \PYG{n}{x5}\PYG{p}{;}
\end{sphinxVerbatim}

ただし、判定は記述した順番に行われます。この例でたとえば y1 ～ y4 全てが 1 だった場合、y1 の条件が採用されます (プライオリティエンコーダ＝選択肢に優先順位のあるセレクタ) 。


\section{条件分岐 with ～ select ～ when ～}
\label{\detokenize{05_try:with-select-when}}

\subsection{演習}
\label{\detokenize{05_try:id8}}
プロジェクト名 vhdl04

条件分岐の書き方の一つ、with ～ select ～ when ～ の例です。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl04} \PYG{k}{is}
  \PYG{k}{port}\PYG{p}{(}
    \PYG{n}{sw1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw3}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw7}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw8}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl04}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl04} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{sw} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{sw} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw8} \PYG{o}{\PYGZam{}} \PYG{n}{sw7}\PYG{p}{;}
  \PYG{k}{with} \PYG{n}{sw} \PYG{k}{select} \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw3} \PYG{k}{when} \PYG{l+s}{\PYGZdq{}11\PYGZdq{}}\PYG{p}{,}
                         \PYG{n}{sw2} \PYG{k}{when} \PYG{l+s}{\PYGZdq{}10\PYGZdq{}}\PYG{p}{,}
                         \PYG{n}{sw1} \PYG{k}{when} \PYG{l+s}{\PYGZdq{}01\PYGZdq{}}\PYG{p}{,}
                         \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}} \PYG{k}{when} \PYG{k}{others}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

sw7 と sw8 の設定により、LED の点滅を制御できるスイッチを切り替えられる回路です。

このコードから生成される回路のイメージは次の通りです。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure09}.eps}
\end{figure}

中央のブロックはセレクタで、上から入力される値がブロック中の値と一致すると、その箇所の信号が出力されます。

選択肢に優先順位がある場合は when ～ else ～、ない場合は with ～ select ～ when ～ を使います。


\section{process 文}
\label{\detokenize{05_try:process}}
AND、OR、NOT などの組み合わせ回路や単純な条件分岐であればこれまでの内容で対応できますが、フリップフロップなどを組み合わせた順序回路を記述するには、process 文を使用します。

ヒント

フリップフロップ専用の記述ではありませんが、フリップフロップを使用する箇所のみ process 文を使うようにしていると、慣れていないうちはトラブルを避けやすくなります。

基本的な構成は以下の通りです。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
LABEL: process (SENSITIVITY\PYGZhy{}LIST)
begin
  ～ EXPRESSION ～
end process;
\end{sphinxVerbatim}

ラベル(LABEL) を付加するかどうかは任意ですが、識別のために固有の名前をつけておくのがよいでしょう。

センシティビティリスト(SENSITIVITY\sphinxhyphen{}LIST) は、この process 文を動作させるトリガになる信号のリストを記述します。

\begin{sphinxadmonition}{note}{注釈:}
センシティビティリストに書いた信号は「トリガ」と書きましたが、その信号が変化した時に必ず process 文の内容が実行されるという話ではなく、その信号が変化したときに、process 文の一番最初の if ～ then ～ elsif ～ else ～ end if の条件で動作する、という点を覚えておきましょう。
\end{sphinxadmonition}

信号名はカンマで区切ります。

式(EXPRESSION) の部分には実際の動作を記述します。ただし条件分岐は、これまでの when ～ else ～ や with ～ select ～ when ～ は使用できません。後ほどでてくる if 文や case 文を使用します (逆に if 文や case 文は process 文の外では使用できません) 。


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{組み合わせ}\label{\detokenize{05_try:id36}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
process 文の
&\sphinxstyletheadfamily 
when ～ else ～
&\sphinxstyletheadfamily 
with ～ select ～ when ～
&\sphinxstyletheadfamily 
if ～ elsif ～ endif
&\sphinxstyletheadfamily 
case ～ end case
\\
\hline
外
&
○
&
○
&
×
&
×
\\
\hline
中
&
×
&
×
&
○
&
○
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{フリップフロップの基本と if 文}
\label{\detokenize{05_try:if}}
フリップフロップは主に D 型、SR 型、JK 型、T 型があります。これらを VHDL で記述するときは一般に process 文を使用します。

フリップフロップのリセットが非同期式の場合、D フリップフロップは以下のように記述します。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nc}{D\PYGZus{}FF}\PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{reset}\PYG{p}{,} \PYG{n}{clock}\PYG{p}{)}
\PYG{k}{begin}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{reset} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
    \PYG{n}{q} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
  \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{clock}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clock} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
    \PYG{n}{q} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
\PYG{k}{end} \PYG{k}{process}\PYG{p}{;}
\end{sphinxVerbatim}

この例では、すべての信号は std\_logic で定義されているとします。

入力データは信号は d 、出力データ信号は q としています。

reset に H レベルの信号を与えるとリセット動作として、q を L レベルにセットしています。

クロック信号 clock が H へ変化すると、q へ d を代入します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure12}.eps}
\end{figure}

動作例を以下に示します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure10}.eps}
\end{figure}

a の期間では reset = \textquotesingle{}1\textquotesingle{} が成り立つので q \textless{}= \textquotesingle{}0\textquotesingle{} が実行され続けます。

b のタイミングでは clock\textquotesingle{}event and clock = \textquotesingle{}1\textquotesingle{} が成り立ちます。これは、clock が変化したこと (clock\textquotesingle{}event) と clock = \textquotesingle{}1\textquotesingle{} の組み合わせで、clock が 0 から 1 に変化したときに成り立つ、という記述の仕方です。このとき q \textless{}= d が実行されます。d が 1 なので最終的には q は 1 になります。

c のタイミングも b のタイミング同様、clock が 0 から 1 に変化したことが成り立っています。q には d の値 0 が代入されます。

d の期間では e や f のタイミングで clock\textquotesingle{}event が成り立っていますが、if 文 (後述) で reset = \textquotesingle{}1\textquotesingle{} が先に記述されているため、e 、f は無視され、q には 0 が出力され続けます。

ちなみに FPGA が起動したとき、フリップフロップの値が H 、L どちらになっているかは決まっていません。そのため図で q はリセットがかかるまではどちらの値かわかりません (不定) 。


\subsection{シミュレーション}
\label{\detokenize{05_try:id9}}
順序回路の動作確認にはシミュレータが役に立ちます。ここでシミュレーションにより上記の動作を確認します。

D:\textbackslash{}Altera\textbackslash{}(学籍番号) に vhdl20 というフォルダを作ります。

Web ブラウザで \sphinxurl{http://vhdl.cottonrose.jp/2016/} を開き、vhdl20.vhd をダウンロードし、先ほどのフォルダにダウンロードします。

\begin{sphinxadmonition}{note}{注釈:}
ダウンロードしたファイルが読み取り専用になっていることがあります。
\end{sphinxadmonition}

別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。

34 ページまで実行すると、上記のような波形が見られます (波形の赤いラインは不定を表します)。

\begin{sphinxadmonition}{note}{注釈:}
自分自身への代入について

process 文の中の if 文の中で、clock\textquotesingle{}event and clock = \textquotesingle{}1\textquotesingle{} の条件の中では、宣言されている signal や variable に自分自身を代入できます。

例えば、a \textless{}= a; はこのままでは無意味なコードですが、正常なものです。これは、この代入動作がクロックの変化点のみ行われるのがポイントです。

これを応用すると、a \textless{}= not a; であればクロックの変化点事に反転、a \textless{}= a + 1; であればカウントアップしていく動きになります。

これが process 文の外、clock\textquotesingle{}event and clock = \textquotesingle{}1\textquotesingle{} の外では、エラーになるか、予測できない動作になります。エラーにならなかった場合、例えば a \textless{}= not a; はデバイスの限界速度で反転を繰り返す信号を生成しますが、スイッチ動作が多すぎて電流消費、発熱から、何が起きるかわかりません。
\end{sphinxadmonition}


\subsection{同期、非同期}
\label{\detokenize{05_try:id10}}
「非同期」動作は、クロックによらず動作する箇所、「同期」動作はクロックの変化点に合わせて動作することを示しています。

先ほどのサンプルでは、リセットは非同期動作 (特にこの場合は「非同期リセット」とも呼ばれる) 、データの保持は同期動作としています。

\begin{sphinxadmonition}{note}{注釈:}
データをクロックに同期して保持するものを一般にフリップフロップ、同期せずに保持するものをラッチと呼びます。

これは「ディジタルコンピューティングシステム」p54 に書かれていることと逆ですが、会社などの組織毎に異なる場合があるので注意が必要です。
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{警告:}
FPGA に実装する回路において、一般にラッチは使用するべきではないとされています。

フリップフロップを使った方が動作が予測しやすいため、デバイス自体にフリップフロップが組み込まれています。それに対しラッチは大規模回路では動作の予測が難しく、バグの元になりやすいため、です。

慣れないうちは、できる限りすべてのフリップフロップは同じクロックで動作するようにし、動作を始める前にはすべて非同期リセットを行うように組むと失敗が少なくなります。
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{注釈:}
「ディジタル回路」は信号レベル (縦軸) を離散的に扱います。「同期回路」は時間軸を離散的に扱うための手法と考えられます。「非同期回路」は時間軸に不確定な要因を持つことになるため、動作の安定性に影響します。

この授業の実習では、その実習で使用するすべてのフリップフロップは同じクロックで動作させるようにします。

これらを守るためには、上の D フリップフロップの例のようなセンシティビティリスト (信号名は回路に合わせる) 、if 文の構成 (非同期リセットとクロックの動作しかなく、それ以上はその if 、elsif の中に書き足していく) を基本にしていきます。
\end{sphinxadmonition}


\subsection{if 文}
\label{\detokenize{05_try:id11}}
条件分岐の基本的なもので、基本的な形は以下の通りです。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (CONDITION) then
  ～ EXPRESSION ～
end if;
\end{sphinxVerbatim}

条件(CONDITION) が真であれば、処理(EXPRESSION) が実行されます。
複数の条件ごとに処理を分ける場合は以下のようになります。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (CONDITION\PYGZus{}A) then
  ～ EXPRESSION\PYGZus{}A ～
elsif (CONDITION\PYGZus{}B) then
  ～ EXPRESSION\PYGZus{}B ～
elsif (CONDITION\PYGZus{}C) then
  ～ EXPRESSION\PYGZus{}C ～
else
  ～ EXPRESSION\PYGZus{}OTHER ～
end if;
\end{sphinxVerbatim}

条件 A (CONDITION\sphinxhyphen{}A) が真であれば処理 A (EXPRESSION\sphinxhyphen{}A) を実行、それ以外で条件 B (CONDITION\sphinxhyphen{}B) が真であれば処理 B (EXPRESSION\sphinxhyphen{}B) 、それ以外で条件 C (CONDITION\sphinxhyphen{}C) が真であれば処理 C (EXPRESSION\sphinxhyphen{}C)、それ以外ではその他の処理(EXPRESSION\sphinxhyphen{}OTHERS) を実行します。

\begin{sphinxadmonition}{note}{注釈:}
一般のプログラミング言語と異なり、「else if」ではなく「elsif」と書きます。
\end{sphinxadmonition}

条件の書き方は、たとえば一致判定では

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{reset} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}
\end{sphinxVerbatim}

不一致判定は

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{reset} \PYG{o}{/}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}
\end{sphinxVerbatim}

数値の大小の比較では、

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{count} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}1010\PYGZdq{}}
\end{sphinxVerbatim}

となります。

条件は複数組み合わせることができ、そのときは and 、or 、not も使用できます。

たとえば

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{and} \PYG{n}{b} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}
\end{sphinxVerbatim}

とすれば、２つの条件が満たされた場合、と判定されます。
クロックの変化点での動作、つまり同期動作について括る場合の条件は、

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{clock}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clock} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}
\end{sphinxVerbatim}

が一般的となります。これは clock の変化点と、clock が H という２つの条件の AND となります。

\begin{sphinxadmonition}{note}{注釈:}
上記のような、クロックの変化点での動作の記述は、一つの if 文で複数書いても文法上は問題ありませんが、実際のデバイス上でそのような動作は行うことができません。
\end{sphinxadmonition}

一般に process 文の最初の if 文の構成は最大で

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (set, reset, clock)
begin
  if (reset = \PYGZsq{}1\PYGZsq{}) then
    ～
  elsif (set = \PYGZsq{}1\PYGZsq{}) then
    ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{}) then
    ～
  end if ;
end process;
\end{sphinxVerbatim}

となります。

リセット時、セット (プリセット) 時、その他通常動作時を同じレベルで設定しています。

以下の書き方は許容されますが、理解できていないうちは行うべきではありません。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (clock)
begin
  if (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{}) then
    ～
  end if;
end process;
process (clock)
begin
  if (clock\PYGZsq{}event and clock = \PYGZsq{}0\PYGZsq{}) then
    ～
  end if;
end process;
\end{sphinxVerbatim}

同じクロックで動作する書き方ですが、1 = クロックの立ち上がりと 0 = クロックの立ち下がりが混在しています。この２つの process 文の間でデータのやりとりがあるとき、デバイス上での動作条件が厳しくなります。

以下の書き方は実機には基本的には組み込めません。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (clock)
begin
  if (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{}) then
    ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}0\PYGZsq{}) then
    ～
  end if;
end process;
\end{sphinxVerbatim}

同じ process 文内で、同じクロックの 1 = クロックの立ち上がりと 0 = クロックの立ち下がりが混在しています。同じ signal に対してこのような動作は指示できません。それぞれの処理に異なる signal を入れれば組み込むことはできますが、一つ前の例と同様使うべきではありません。


\subsection{マルチソース}
\label{\detokenize{05_try:id12}}
HDL では、基本的に全ての行が、常に「同時」に動作していると考える必要があります。この点が、ソースコードを逐次解釈していくソフトウェアと大きく異なる点です。

これにより、signal や port への値の代入の仕方に制限があります。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{test} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{a} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

ソフトウェアであればこの場合、a に 0 が代入された後でさらに a に 1 が代入されます。
しかし HDL の場合、0 と 1 の代入は同時に行おうとし、論理合成の段階でエラーとなります (エラーメッセージには multi source という言葉が含まれます) 。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{entity} \PYG{n+nc}{x} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{d1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{d2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{clk} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{q}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)} \PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{x}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{x} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{a} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{a\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{clk}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clk} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{b\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{clk}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clk} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d2}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{q} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;}

\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

別々の process 文で動作させていても、同じ signal に代入しようとしているため、両方の条件が必ず衝突しない書き方出ない限り論理合成でエラーになります (そしてそのように書いたとしても不具合の修正なので書き換えているうちに条件が崩れ multi source のエラーになりやすいです) 。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{entity} \PYG{n+nc}{x} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{d1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{d2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{clk} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{q}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)} \PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{x} \PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{x} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{a} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{a} \PYG{n}{proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{clk}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{clk}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clk} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d2}\PYG{p}{;}
  \PYG{n}{q} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;}

\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

このような process 文での順序回路と、通常の組み合わせ回路でも同様です。


\subsection{process 文、if 文によるフリップフロップの記述のお約束}
\label{\detokenize{05_try:process-if}}
この教科書ではこの先順序回路を多く使用します。その際、後々のトラブルを避けるため、以下のような書き方を避けることをおすすめします。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (reset, clock, a, b)
begin
  if (reset = \PYGZsq{}1\PYGZsq{}) then
    ～ RESET\PYGZhy{}PROCEDURE ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{} and a = \PYGZsq{}1\PYGZsq{}) then
    ～ PROCEDURE\PYGZhy{}A ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{} and b = \PYGZsq{}1\PYGZsq{}) then
    ～ PROCEDURE\PYGZhy{}B ～
  end if;
end process;
\end{sphinxVerbatim}

どうやら、リセット処理(RESET\sphinxhyphen{}PROCEDURE)、クロックに同期した上で a が 1 の時の処理(PROCEDURE\sphinxhyphen{}A)、クロックに同期した上で b が 1 の時の処理(PROCEDURE\sphinxhyphen{}B)を行いたいらしい。

このような場合は以下のように、クロックによる動作と論理を分離して記述すると良いでしょう。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (reset , clock)
begin
  if (reset = \PYGZsq{}1\PYGZsq{}) then
    ～ RESET PROCEDURE ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{}) then
    if (a = \PYGZsq{}1\PYGZsq{}) then
      ～ PROCEDURE A ～
    elsif (b = \PYGZsq{}1\PYGZsq{}) then
      ～ PROCEDURE B ～
    end if;
  end if;
end process ;
\end{sphinxVerbatim}

クロックの条件に追加で書いていると、この授業のレベルではその箇所でミスをしやすくなります。

またクロックの条件と分離することで、他へのコピー＆ペーストでのミスも減ります。

このほか、以下の箇所で代入を行っても、意図した動作にならない可能性が高いです。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
process (reset , clock)
begin
  if (reset = \PYGZsq{}1\PYGZsq{}) then
    ～ RESET PROCEDURE ～
  elsif (clock\PYGZsq{}event and clock = \PYGZsq{}1\PYGZsq{}) then
    ～ MAIN PROCEDURE ～
  end if;
  a \PYGZlt{}= b;
end process;
\end{sphinxVerbatim}

a へ b を代入していますが、この位置ではセンシティビティリストに入る reset と clock の条件を無視した位置にあるため、どのような動作になるか保証できません。

process 文の外か、if 文の中に入れましょう。


\subsection{演習}
\label{\detokenize{05_try:id13}}
プロジェクト名 vhdl05

D フリップフロップを作る

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee} \PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl05} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{sw1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic} \PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} data}
    \PYG{n}{sw2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic} \PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} clock}
    \PYG{n}{sw3}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic} \PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} reset}
    \PYG{n}{led1} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl05}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl05} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{d} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{dff} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{sw2}\PYG{p}{,} \PYG{n}{sw3}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw3} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
    \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{sw2}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{sw2} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sw1}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

ヒント

"\sphinxhyphen{}\sphinxhyphen{}" (マイナス２個) 以降は改行までコメントとして無視されます。

この例では、sw1 をデータ入力、sw2 をクロック、sw3 をリセットとして使用しています。

シグナル d を D フリップフロップの実態という意味で定義しています。

sw3 を H にすると、フリップフロップをリセットします。

sw2 が H に変化したタイミング (立ち上がりエッジ) で、sw1 の内容を d へ代入します。そのほかのタイミングでは sw1 の変化の影響を受けません。

process 文内の処理は sw2 と sw3 の変化でしか行われないため、センシティビティリストには sw2 と sw3 しか書いていません。

led1 には d の内容を出力しています。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure13}.eps}
\end{figure}

動作確認
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
sw1、sw2、sw3 をすべて OFF にする。

\item {} 
まず sw3 を ON \(\rightarrow\) OFF して、リセットする。

\item {} 
sw2 を ON \(\rightarrow\) OFF して、led1 が変化しないことを確認する。 (入力データ sw1 が OFF なので、OFF のデータを改めてサンプルするだけ)

\item {} 
sw1 を ON にする。

\item {} 
sw2 を ON \(\rightarrow\) OFF して、 led1 が変化することを確認する。

\item {} 
sw1 を OFF にしても led1 が変化しないことを確認する。

\item {} 
sw2 を ON \(\rightarrow\) OFF して、 led1 が変化することを確認する。

\end{enumerate}


\subsection{課題}
\label{\detokenize{05_try:id14}}
プロジェクト名 vhdl06

下記のソースコードに追記して、JK フリップフロップを作れ

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl06} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{sw1}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} J}
    \PYG{n}{sw2}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} clock}
    \PYG{n}{sw3}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} K}
    \PYG{n}{sw4}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} reset}
    \PYG{n}{led1} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl06}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl06} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{jk} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{jkff\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{sw4}\PYG{p}{,} \PYG{n}{sw2}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw4} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}

       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
    \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{sw2}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{sw2} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}

       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{jk}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

２箇所の"put code below" から"put code above" の間にコードを書いてください。

ソースコード中で指定しているようなスイッチのアサインで、JK フリップフロップを作成してください。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure14}.eps}
\end{figure}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{真理値表}\label{\detokenize{05_try:id37}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
sw2 (clock)
&\sphinxstyletheadfamily 
sw1(J)
&\sphinxstyletheadfamily 
sw3(K)
&\sphinxstyletheadfamily 
led1(Q \(\rightarrow\) jk)
\\
\hline
↑以外
&
X
&
X
&
維持
\\
\hline
↑
&
0
&
0
&
維持
\\
\hline
↑
&
1
&
0
&
1
\\
\hline
↑
&
0
&
1
&
0
\\
\hline
↑
&
1
&
1
&
反転
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{注釈:}
「維持」は、自分自身を代入することで行えます。
\end{sphinxadmonition}

動作確認は以下の通り行います。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
sw1 ～ sw4 を OFF にする。

\item {} 
sw4 を ON \(\rightarrow\) OFF として、リセットする (led1 が点灯する) 。

\item {} 
sw1 を ON \(\rightarrow\) OFF として、led1 が変化しないことを確認する (J だけ動かしている) 。

\item {} 
sw3 を ON \(\rightarrow\) OFF として、led1 が変化しないことを確認する (K だけ動かしている) 。

\item {} 
sw1 を ON にし、sw2 を ON \(\rightarrow\) OFF として、led1 が消灯することを確認する。

\item {} 
sw1 を OFF にし、sw2 を ON \(\rightarrow\) OFF としても、led1 が消灯したままであることを確認する。

\item {} 
sw3 を ON にし、sw2 を ON \(\rightarrow\) OFF として、led1 が点灯することを確認する。

\item {} 
sw3 を OFF にし、sw2 を ON \(\rightarrow\) OFF としても、led1 が点灯したままとなることを確認する。

\item {} 
sw1 、sw3 を ON にし、sw2 を ON \(\rightarrow\) OFF として、led1 が消灯することを確認する (注記参照) 。

\item {} 
sw1 、sw3 を ON にしたままで、sw2 を ON \(\rightarrow\) OFF として、led1 が点灯することを確認する (注記参照) 。

\end{enumerate}

\begin{sphinxadmonition}{note}{注釈:}
最後の２つは、想定通りに動いたり、動かなかったりする。これは後述するチャタリングが原因。
\end{sphinxadmonition}


\section{カウンタ}
\label{\detokenize{05_try:id15}}
フリップフロップはクロックに合わせて値を保持します。複数ビットのフリップフロップの組み合わせの出力に加算器を接続し、その結果をフリップフロップに戻すことで、次のクロックでは加算後の結果が保持されます。

加える値が１であれば、１ずつ増えていくカウンタとなります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure15}.eps}
\end{figure}

プロジェクト名 vhdl07

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl07} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led2}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led3}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led4}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led5}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led6}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led7}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led8}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl07}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl07} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{24} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{count} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led8} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{24}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led7} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led6} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{22}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led5} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{c} \PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

クロックはあらかじめ、32MHz を選択しておきます (JP3、JP4、JP5 のうち JP5 だけショートさせる) 。

カウンタの信号は c で、process 文 count の中でクロックの立ち上がりエッジの度に１を加えます。

c の幅は 25bit なので、0 ～ 33,554,431 までの値を扱うことができます。入力しているクロックが 32MHz なので、約1秒で一周するよう、LED が点灯します。

LED には、上位 8bit のみ表示しています。

この記述では、ソフトウェアの for や while のようなループが書かれていませんが、センシティビティリストの gclk0 の変化 = クロックの変化毎にプロセス文の記述が呼び出されるため、自動的に繰り返し実行されます。


\section{分周回路と T フリップフロップ}
\label{\detokenize{05_try:t}}

\subsection{分周回路}
\label{\detokenize{05_try:id16}}
カウンタを応用した回路構成の一つで、元の周波数の整数分の１の周波数を作り出します。

２分周 ( 1/2 の周波数) 、４分周 ( 1/4 の周波数) 、８分周 ( 1/8 の周波数) の例を図に示します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure16}.eps}
\end{figure}

２分周を超える場合、作られる信号の形は２つのパターンがあります。

一つは、デューティ比 ( H レベルと L レベルの期間の比) ができるだけ５０：５０になるよう近づけたパターン。

もう一つは、作り出した周期の中で１クロック分だけ H レベルとし、残りは L とするパターン。

通常デバイス内では後者、デバイスの外では前者が使われることが多いです。

４分周の２つめのパターンの例を以下に示します。

プロジェクト名 vhdl08

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee} \PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl08} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led2}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl08}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl08} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{r} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{div\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}

      \PYG{c+c1}{\PYGZhy{}\PYGZhy{} make 1/4 frequency}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}11\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{else}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{led2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

この中で c は１０進数で０～３までカウントし、r にはそのうち３のときだけ \textquotesingle{}1\textquotesingle{} がセットされます。その反転による LED の点灯がされるため、gclk0 32MHz で４周期のうち１サイクルだけ点灯することになり、結果として単純に点灯している led2 に比べ led1 が暗くなります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure17}.eps}
\end{figure}


\subsection{課題}
\label{\detokenize{05_try:id17}}
プロジェクト名 vhdl09
\begin{description}
\item[{約１秒周期で led1 の点灯、消灯を繰り返す回路を作れ}] \leavevmode
(約 0.5 秒点灯、約 0.5 秒消灯を繰り返す)

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl09} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
  \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{n}{led1}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl09}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl09} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{24} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} counter}
  \PYG{k}{signal} \PYG{n}{r} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} invert t when it is H level}
  \PYG{k}{signal} \PYG{n}{t} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;} \PYG{c+c1}{\PYGZhy{}\PYGZhy{} T flipflop}
\PYG{k}{begin}
  \PYG{n}{cnt\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}

       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{t\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}

       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{t}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

分周回路と T フリップフロップ (のような動作) を組み合わせて作成します。基板上、JP5 のジャンパをショートし、gclk0 の周波数を 32MHz に設定します。

2カ所のスペースのうち、一つ目には分周回路、二つ目には T フリップフロップを構成します。

分周回路は、１クロックだけ H レベルを作るような構成にする必要があります。先ほどの分周回路では "11" と比較していたところを、今回は (2\textasciicircum{}25)\sphinxhyphen{}1 、つまり"111111111111111111111111"と比較することになります。このときに r を 1 に、それ以外の値の時は 0 にセットします。

T フリップフロップは単純で、入力信号が 1 であれば反転、0 であればデータを維持します。

\begin{sphinxadmonition}{note}{注釈:}
signal 宣言した信号は、その architecture 内でグローバル変数のように働きます。同じ architecture 内にある全ての process 文内から読み出すことができます。
\end{sphinxadmonition}

r は、32MHz を 33,554,431 回カウントする毎に 1 になるため、そのたびに t が反転されます。それを led1 に出力すれば、目的の回路ができあがります。


\section{積分回路とチャタリング除去}
\label{\detokenize{05_try:id18}}
機械的なスイッチは、切り替えたときに信号の状態が不安定な期間があります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure18}.eps}
\end{figure}

この不安定な期間は数 ms 程度続く場合もあります。人間にとっては感知できないほど短い時間ですが、FPGA は動作が十分速いため、この細かい変化を検出し、反応してしまいます。たとえば課題 vhdl06 ではこれにより不安定な動作となっています。

そのため、それを除去する回路を組み込む必要があります。これには積分回路を応用します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure19}.eps}
\end{figure}

積分回路は基本的にはカウンタです。入力を単純に加算していきます。これを応用し、H が入力されている間は上限まで加算 (上限まで来たら値を維持) 、一度でも L が来たら値をクリアします。

この応用した回路に、スイッチからの信号を入力します。スイッチを切り替えない期間では、カウンタの値は０か最大のいずれかで安定します。

スイッチを切り替えた時、入力は H と L が激しく切り替わります。応用した回路では入力の H が一定期間維持されると H を出力するよう動作しますので、この「一定期間」が数ミリ秒となるようなカウンタの最大値を設定すれば良いことになります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure20}.eps}
\end{figure}

応用回路はたとえば以下のようなソースになります。clock は積分していくサイクル、sw1 がチャタリングのあるスイッチからの入力、r がチャタリング除去後の出力です。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{process} \PYG{p}{(}\PYG{n}{clock}\PYG{p}{)}
\PYG{k}{begin}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{clock}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{clock} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw1} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}000000000000000\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{c} \PYG{o}{/}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{sw1} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
    \PYG{k}{else}
      \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
\PYG{k}{end} \PYG{k}{process}\PYG{p}{;}
\end{sphinxVerbatim}

最初の if 文では、カウンタによる積分回路を構成しています。

スイッチを 0 側に倒されたら (sw1 = \textquotesingle{}0\textquotesingle{}) カウンタの値は即０とします。

スイッチが 1 側に倒されたら (sw1 = \textquotesingle{}1\textquotesingle{}) 、カウンタがいっぱいでなければ (c /= "111111111111111"、"/="は"一致していない" の意味) カウントします (c \textless{}= c + 1) 。

このカウンタは、スイッチが 1 側に倒されれば、カウンタのビットがすべて１になるまでカウントを続け、0 側に倒されればすぐにすべて０に戻します。

スイッチからの信号が不安定な状態では、少しでも０がくればカウンタも０に戻されますが、十分安定すれば最後までカウントします。

32MHz であれば１周期は約 31ns なので、15bit で 32000 回カウントすれば約１ｍｓになります。スイッチが約１ｍｓ安定すれば、最後までカウントされることになります。

次の if 文では、前のカウンタが最後までカウントされたら１、それ以外は０を出力します。スイッチ入力が安定したことを判定することができます。

このままでは１ｍｓしか対応できないため、チャタリングが除去し切れていないように見える場合はカウンタのビットを追加する必要があります。

\begin{sphinxadmonition}{note}{注釈:}
std\_logic\_vector の桁数が、比較演算子の左右で一致していない場合、正しく比較されない場合があります。
思ったように動作しない場合は、桁数も確認してください。
\end{sphinxadmonition}


\subsection{シミュレーション}
\label{\detokenize{05_try:id19}}
チャタリング除去の動作をシミュレーションで確認します。

D:\textbackslash{}Altera\textbackslash{}(学籍番号) に vhdl21 というフォルダを作ります。

Web ブラウザで \sphinxurl{http://vhdl.cottonrose.jp/2016/} を開き、vhdl21.vhd をダウンロードし、先ほどのフォルダにダウンロードします。

\begin{sphinxadmonition}{note}{注釈:}
ダウンロードしたファイルが読み取り専用になっていることがあります。
\end{sphinxadmonition}

別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。

signal の s\_switch が、人間がイメージしているスイッチの ON/OFF です。

sw1 は FPGA からみた入力信号を模擬しています。

r が、チャタリング除去後の信号で、s\_switch よりは時間が短いものの、sw1 のような信号のばたつきが無くなっていることが分かります。

シミュレーション完了後、Wave のエリアで signal c に対し右クリック \(\rightarrow\) Radix \(\rightarrow\) Unsigned 、もう一度右クリック \(\rightarrow\) Format \(\rightarrow\) Analog (Automatic) で、チャタリング除去に使用したカウンタの値の変化を違った形で見ることができます。
チャタリングが出ているときは、ここでは 1 までしかカウントできず直ぐに 0 に戻されていることが分かります。


\section{微分回路}
\label{\detokenize{05_try:id20}}
人間や機械からの信号= 遅い信号と高速な内部の回路とのインタフェースをしやすくする回路です。

たとえばスイッチを動かす度に LED の点灯、消灯を切り替えたいとします。タイミングチャートは以下のようなものです。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure21}.eps}
\end{figure}

スイッチ入力をクロックとして T フリップフロップに入力できれば実現できますが、同期動作ではないためトラブルの原因になりやすく、採用できません。

出力の信号を生成しているフリップフロップのクロックが十分遅ければやはり T フリップフロップで対応できそうですが、今回のボードに限らず通常は MHz 級の動作周波数ですのでそのような動作はできません。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure22}.eps}
\end{figure}

スイッチ入力の変化点を検出する回路ができれば、T フリップフロップでも望みの動作が可能になります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure23}.eps}
\end{figure}

変化点を検出するため、微分回路と呼ばれる回路を使用します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure24}.eps}
\end{figure}

原理は簡単で、フリップフロップ２段を通して１クロックずつ遅延した信号の間の特定の差だけを抽出します。

実際の回路は以下のようになります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure25}.eps}
\end{figure}


\subsection{演習}
\label{\detokenize{05_try:id21}}
プロジェクト名 vhdl10

スイッチを往復させる毎に LED の点灯、消灯を切り替える回路を作る。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl10} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw1}   \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl10}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl10} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c}  \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{14} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{r}  \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{d1} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{d2} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s}  \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{t}  \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} chattering cancel}
  \PYG{n}{sum\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw1} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}000000000000000\PYGZdq{}}\PYG{p}{;}
      \PYG{k}{elsif} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c} \PYG{o}{/}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{sw1} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

      \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{else}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} difference}
  \PYG{n}{diff\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{d2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1}\PYG{p}{;}
      \PYG{n}{d1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}
  \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1} \PYG{k}{and} \PYG{p}{(}\PYG{k}{not} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+c1}{\PYGZhy{}\PYGZhy{} T flipflop}
  \PYG{n}{t\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{s} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{t}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{t}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

diff proc とその直後の s への代入が微分回路になります。


\section{１０進カウンタ}
\label{\detokenize{05_try:id22}}

\subsection{課題}
\label{\detokenize{05_try:id23}}
プロジェクト名 vhdl11

０～９まで、１秒間に１ずつカウントする、１０進カウンタを作れ。カウント値は９の次は０に戻る。
signal r は１秒に１回、１サイクルだけ H レベルになる信号となる。
led1 が点滅する場合は誤りがある。

プロセス文 div\_proc が１秒を作る。それを利用してプロセス文 cnt\_proc 内で signal c で０～９をカウントする。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee} \PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl11} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1a} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1b} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1c} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1d} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1e} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1f} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1g} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl11}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl11} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{d}    \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{24} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{r}    \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{c}    \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{sled} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{ck}   \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{div\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{d} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1111010000100011111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000000000000000000000000\PYGZdq{}}\PYG{p}{;}
      \PYG{k}{else}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{cnt\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}


       \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{chk\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1010\PYGZdq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{r} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{ck} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{ck}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{sled} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1001\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1000\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0111\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0110\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0010010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0101\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0011001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0100\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0110000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0011\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0100100\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0001\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000110\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{sled1a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1b} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1e} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1f} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sled1g} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{ck}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

７セグメント LED の点灯パターンはコードの通りになる、LED の配置は図のようになっています。port に L を出力すると、電位差で電流が流れ LED が点灯します。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure26}.eps}
\end{figure}


\section{階層設計}
\label{\detokenize{05_try:id24}}
規模が大きくなってくると、すべてのコードを一つの architecture に書ききることが問題になります。そのためコードを機能ブロック毎に分割し呼び出すことができるようになっています。
例を以下に示します。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
library ieee;
use ieee.std\PYGZus{}logic\PYGZus{}1164.all;
use ieee.std\PYGZus{}logic\PYGZus{}arith.all;
use ieee.std\PYGZus{}logic\PYGZus{}unsigned.all;

entity Y\PYGZus{}child is
  port (
  ～ PORT\PYGZus{}DEFINITION(CHILD) ～
  );
end Y child ;

architecture A\PYGZus{}Y\PYGZus{}child of Y\PYGZus{}child is
  ～ SIGNAL\PYGZus{}DEFINITION(CHILD) ～
begin
  ～ EXPRESSIONS(CHILD) ～
end A Y chi ld ;


library ieee ;
use ieee.std\PYGZus{}logic\PYGZus{}1164.all;
use ieee.std\PYGZus{}logic\PYGZus{}arith.all;
use ieee.std\PYGZus{}logic\PYGZus{}unsigned.all;

entity X\PYGZus{}parent is
  port (
    ～ PORT\PYGZus{}DEFINITION(PARENT) ～
  );
end X\PYGZus{}parent;

architecture A\PYGZus{}X\PYGZus{}parent of X\PYGZus{}parent is

  component Y\PYGZus{}child
    port (
      ～ PORT\PYGZus{}DEFINITION(CHILD) ～
    );
  end component;

  ～ SIGNAL\PYGZus{}DEFINITION(PARENT) ～

begin

  i\PYGZus{}Y\PYGZus{}child : Y\PYGZus{}child
    port map (
      ～ PORT\PYGZus{}CONNECTION(CHILD PARENT) ～
    );

  ～ OTHER\PYGZus{}EXPRESSIONS(PARENT) ～

end A\PYGZus{}X\PYGZus{}parent;
\end{sphinxVerbatim}

処理を抜き出した、他から呼び出される側の entity は、通常通り作成します。

処理を呼び出す場合は２段階の手続きがあります。

まず architecture から begin までの間で、component 宣言を行います。ここで、呼び出す entity はすべて宣言します。

次に begin の後で、実際に呼び出します。複数個呼び出すこともできますが、その場合は entity 名の前のコロンの前、インスタンス名 (ここでは i\_Y\_child ) はそれぞれ固有のものにします。


\subsection{演習}
\label{\detokenize{05_try:id25}}
１０進数カウンタに階層化を適用します。

\begin{sphinxadmonition}{note}{注釈:}
counter10.vhd と ledconv.vhd は、vhdl11b プロジェクトを作成した後、それぞれ vhdl11b.vhd と同様に file \(\rightarrow\) new \(\rightarrow\) VHDL file で作成します。
\end{sphinxadmonition}

counter10.vhd

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{counter10} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

    \PYG{n}{e\PYGZus{}in} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{c\PYGZus{}in} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

    \PYG{n}{c\PYGZus{}out} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

    \PYG{n}{cnt} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{)} \PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{counter10}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{counter10} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{cnt\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{sw2}\PYG{p}{,} \PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw2} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{e\PYGZus{}in} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{c\PYGZus{}in} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code below \PYGZhy{}\PYGZhy{}}

        \PYG{c+c1}{\PYGZhy{}\PYGZhy{} put code above \PYGZhy{}\PYGZhy{}}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{c\PYGZus{}out} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1001\PYGZdq{}}\PYG{p}{)}
      \PYG{k}{else} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
  \PYG{n}{cnt} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

c\_in は下の桁からの桁上げのリクエストを受け付けるポート、c\_out は上の桁への桁上げのリクエストを出力するポートです。

e\_in は H レベルが入るとカウントを行うポートです。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{e\PYGZus{}in} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{c\PYGZus{}in} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
\end{sphinxVerbatim}

の箇所は、これまでのカウンタのソースでの r = \textquotesingle{}1\textquotesingle{} に相当します。

ledconv.vhd

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{ledconv} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{cnt} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sledxa} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxb} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxc} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxd} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxe} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxf} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sledxg} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{ledconv}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{ledconv} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{sled} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{sled} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1001\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1000\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0111\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0110\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0010010\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0101\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0011001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0100\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0110000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0011\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0100100\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0010\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1111001\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0001\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}1000000\PYGZdq{}} \PYG{k}{when} \PYG{p}{(}\PYG{n}{cnt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000\PYGZdq{}}\PYG{p}{)}
     \PYG{k}{else} \PYG{l+s}{\PYGZdq{}0000110\PYGZdq{}}\PYG{p}{;}
  \PYG{n}{sledxa} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxb} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxc} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxd} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxe} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxf} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sledxg} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{sled} \PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

sledxa から sledxg は７セグ LED の各端子に相当します。vhdl11b では１桁のみ使うため、sled1a ～ sled1g と対応させています。これが４桁になる場合、ledconv を４個用意し、sled1a ～ sled1g から sled4a ～ sled4g までに対応させます。

プロジェクト名 vhdl11b

vhdl11b.vhd

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl11b} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1a} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1b} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1c} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1d} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1e} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1f} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sled1g} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl11b}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl11b} \PYG{k}{is}
  \PYG{k}{component} \PYG{n+nc}{counter10}
    \PYG{k}{port} \PYG{p}{(}
      \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sw2}   \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

      \PYG{n}{e\PYGZus{}in}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{c\PYGZus{}in}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

      \PYG{n}{c\PYGZus{}out} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

      \PYG{n}{cnt}   \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{component}\PYG{p}{;}

  \PYG{k}{component} \PYG{n+nc}{ledconv}
    \PYG{k}{port} \PYG{p}{(}
      \PYG{n}{cnt}    \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sledxa} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxb} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxc} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxd} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxe} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxf} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sledxg} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
    \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{component}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{d}      \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{24} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{r}      \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{c\PYGZus{}in1}  \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{c\PYGZus{}out1} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{cnt1}   \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{div\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{d} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}1111010000100011111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}0000000000000000000000000\PYGZdq{}}\PYG{p}{;}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{else}
        \PYG{n}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{c\PYGZus{}in1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}

  \PYG{n}{i\PYGZus{}counter1} \PYG{o}{:} \PYG{n}{counter10}
    \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw2}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2}\PYG{p}{,}
      \PYG{n}{e\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{r}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{c\PYGZus{}in1}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{c\PYGZus{}out1}\PYG{p}{,}
      \PYG{n}{cnt}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{cnt1}
    \PYG{p}{)}\PYG{p}{;}

  \PYG{n}{i\PYGZus{}conv1} \PYG{o}{:} \PYG{n}{ledconv}
    \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{cnt}    \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{cnt1}\PYG{p}{,}
      \PYG{n}{sledxa} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1a}\PYG{p}{,}
      \PYG{n}{sledxb} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1b}\PYG{p}{,}
      \PYG{n}{sledxc} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1c}\PYG{p}{,}
      \PYG{n}{sledxd} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1d}\PYG{p}{,}
      \PYG{n}{sledxe} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1e}\PYG{p}{,}
      \PYG{n}{sledxf} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1f}\PYG{p}{,}
      \PYG{n}{sledxg} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sled1g}
    \PYG{p}{)}\PYG{p}{;}

\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

この状態で、ソースコードの関係は以下のようになります。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{figure27}.eps}
\end{figure}

counter10 を呼び出しているときのキーワード "i\_counter1" や ledconv に対する "i\_conv1" がインスタンス名となります。固有のインスタンス名をつけることで、同じ回路ブロックを複数回呼び出すことができます。

ポートの接続はこのコードのように、左辺に呼び出される回路のポート名、=\textgreater{} をはさんで右辺に呼び出し側の port 名または signal 名を書き、カンマで区切ります。カンマは区切りなので最後の接続の後には書きません。


\subsection{シミュレーション \& 演習}
\label{\detokenize{05_try:id26}}
\begin{sphinxadmonition}{note}{\label{\detokenize{05_try:id27}}課題:}
タイミングチャートの読み方がわからない
\end{sphinxadmonition}

先ほどの階層設計を応用して、10 進数 3 桁のカウンタを作り、シミュレータ上で動作を確認します。

D:\textbackslash{}Altera\textbackslash{}(学籍番号) に vhdl22 というフォルダを作ります。

Web ブラウザで \sphinxurl{http://vhdl.cottonrose.jp/2016/} を開き、vhdl22.vhd をダウンロードし、先ほどのフォルダにダウンロードします。

\begin{sphinxadmonition}{note}{注釈:}
ダウンロードしたファイルが読み取り専用になっていることがあります。
\end{sphinxadmonition}

vhdl11b で使った counter10.vhd も、このフォルダにコピーしておきます。

別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。

途中のコンパイルでは \sphinxstylestrong{先に counter10.vhd をコンパイル} しておきます。

このソースコードは、そのままでは 10 進数のカウンタが 3 個並び、同じようにカウントするだけになっています。

これを \sphinxstylestrong{改造} し、10 進数 3 桁のカウンタにしてください。

ソースコードの抜粋を以下に示します。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} COUNTERS \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{n}{i\PYGZus{}counter\PYGZus{}0}\PYG{o}{:} \PYG{n}{counter10}
  \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw2}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2}\PYG{p}{,}
      \PYG{n}{e\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}0}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}0}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}0}\PYG{p}{,}
      \PYG{n}{cnt}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}cnt\PYGZus{}0}
  \PYG{p}{)}\PYG{p}{;}

\PYG{n}{i\PYGZus{}counter\PYGZus{}1}\PYG{o}{:} \PYG{n}{counter10}
  \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw2}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2}\PYG{p}{,}
      \PYG{n}{e\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}1}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}1}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}1}\PYG{p}{,}
      \PYG{n}{cnt}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}cnt\PYGZus{}1}
  \PYG{p}{)}\PYG{p}{;}

\PYG{n}{i\PYGZus{}counter\PYGZus{}2}\PYG{o}{:} \PYG{n}{counter10}
  \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw2}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2}\PYG{p}{,}
      \PYG{n}{e\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}2}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}in}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}2}\PYG{p}{,}
      \PYG{n}{c\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}2}\PYG{p}{,}
      \PYG{n}{cnt}   \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{s\PYGZus{}cnt\PYGZus{}2}
  \PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} edit connection here \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}0} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
\PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}0} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}0}

\PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
\PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}1}

\PYG{n}{s\PYGZus{}e\PYGZus{}in\PYGZus{}to\PYGZus{}2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
\PYG{n}{s\PYGZus{}c\PYGZus{}in\PYGZus{}to\PYGZus{}2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} s\PYGZus{}c\PYGZus{}out\PYGZus{}from\PYGZus{}2}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}

ソースコード中の edit connection here にある 9 つの signal の接続を編集することで実現できます。

counter10 の e\_in と c\_in は、両方に 1 が入力されるとカウントするように働きます。
c\_out は、カウント値が 9 の時に 1 になります。

counter10 のポートの役割は以下の通りです。
\begin{description}
\item[{gclk0}] \leavevmode
クロック入力

\item[{sw2}] \leavevmode
リセット入力

\item[{e\_in}] \leavevmode
カウントしたいタイミングの入力

\item[{c\_in}] \leavevmode
下の桁からの桁上げ信号の入力

\item[{c\_out}] \leavevmode
上の桁への桁上げ信号の出力

\end{description}

3 桁分の counter10 から合計 9 つの signal が引き出されています。

一度シミュレータでこれらの信号の動きを確認し、要求通りの動作をするように、signal の接続を変更してください。

シミュレーション用のコードは判定機能を持っています。

Transcript エリアに "Simulation finished with 0 errors." と表示されると、正しく動作したと判定されます。

もし数字が 0 でなかったり、"Simulation timed out with \sphinxstylestrong{* errors." (*} は数字 ) と表示されたら、何かしらのエラーがあることになります。


\section{状態遷移と、条件分岐 case ～ when ～}
\label{\detokenize{05_try:case-when}}
例えばカップラーメンを食べようとした場合でも、 (誰かが作ってくれる場合を除いて) 手順があります。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
カップラーメンの包装をといてふたを開けて小袋をとりだす。必要なものはここで入れる。

\item {} 
やかんに水を入れてコンロにかけて沸かす。

\item {} 
沸騰するのを待つ。

\item {} 
沸騰したら火を止めて、お湯をカップに注ぐ。

\item {} 
３分 (または５分) 待つ。

\item {} 
必要に応じて小袋の中身をカップに入れる。まぜる。

\item {} 
食べてよし。

\end{enumerate}

小袋が入ってなかったり電気ポットでお湯を沸かしたり、湯切りタイプだったりとバリエーションがありますが、オーソドックなものではこのように順番があり、例えば１、２は入れ替えたり並列に行ってもいいですが、基本的に手順通りに行います。

プログラミングもこういったところに似ていますが、このように手順通りに処理を行いたい場合、ソフトウェアと同様状態遷移の考え方を使います。

状態遷移は通常は図で状態間のつながりを描きながら設計をし、ソースコードには人間が考えながら書き込むしかありません (図を描くことでソースコードを出力してくれるツールもあります) 。

ソースコード上で、各「状態」を数字で表しながらコーディングすることもできますが、各「状態」に名前をつけて管理しやすくすることができます。
\begin{quote}

( C 言語の enum と同じような働きです)
\end{quote}

使い方はたとえば以下のようになります。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type} \PYG{n}{RAMEN} \PYG{k}{is} \PYG{p}{(}\PYG{n}{MAKE\PYGZus{}READY\PYGZus{}CUP}\PYG{p}{,} \PYG{n}{BOILWATER}\PYG{p}{,} \PYG{n}{POURWATER}\PYG{p}{,} \PYG{n}{WAIT\PYGZus{}MINUTES}\PYG{p}{,} \PYG{n}{READY\PYGZus{}TO\PYGZus{}EAT}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{signal} \PYG{n}{ramen\PYGZus{}stat} \PYG{o}{:} \PYG{n}{RAMEN}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{ramen\PYGZus{}stat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{MAKEREADY}\PYG{p}{;}
\end{sphinxVerbatim}

１行目では RAMEN という型を新しく定義しています。この型のとりうる値は"MAKE\_READY\_CUP"以降の５種類です。

２行目では、RAMEN の型の signal 、ramen\_stat を宣言します。

ramen\_stat には MAKE\_READY\_CUP など、定義した名前を代入したり、if 文で比較したりすることができます。ただし勝手に作った型ですので、そのままでは port から出力しても使えませんし、例えば LED の点灯パターンに対しては全く対応がとれないため使えません。あくまで内部で使うのが基本です。

このようにしなくても、自分でこれらの状態を管理すれば、たとえば integer の signal ででも管理できます。ただしわかりやすい名前をつけることで、ソースコードが理解しやすくなります。


\section{条件分岐 case ～ when ～}
\label{\detokenize{05_try:id28}}
\begin{sphinxadmonition}{note}{注釈:}
case 文は process 文の中でのみ使用できます。

状態遷移専用ではありませんが、case 文はよく組み合わされて使われます。基本的な形は以下の通りです。
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
case (CONDITION\PYGZus{}SIGNAL) is
  when (VALUE\PYGZus{}A) =\PYGZgt{} ～ EXPRESSION A ～
  when (VALUE\PYGZus{}B) =\PYGZgt{} ～ EXPRESSION B ～
  when others =\PYGZgt{} ～ EXPRESSION OTHER ～
end case;
\end{sphinxVerbatim}

ある一つの signal の値毎に処理を分岐させることができます。処理は、次の when まで何行でも書くことができます。


\subsection{演習}
\label{\detokenize{05_try:id29}}
スイッチによって、特定の LED を点灯させる回路を作る。
* LED1 が点灯している場合、sw2 を操作することで LED1 が消灯し、LED2 が点灯する。
* LED2 が点灯している場合、sw1 を操作することで LED2 が消灯し、LED1 が点灯する。sw2 を操作した場合は、LED2 が消灯し、LED3 が点灯する。
* LED3 が点灯している場合、sw1 を操作することで LED3 が消灯し、LED2 が点灯する。

swfilter.vhd

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee} \PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{swfilter} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw\PYGZus{}out} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{swfilter}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{swfilter} \PYG{k}{is}
  \PYG{k}{signal} \PYG{n}{c} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{14} \PYG{k}{downto} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{r} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{d1} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{d2} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{s} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{sum\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}000000000000000\PYGZdq{}}\PYG{p}{;}
      \PYG{k}{elsif} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c} \PYG{o}{/}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{and} \PYG{p}{(}\PYG{n}{sw} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}

      \PYG{k}{if} \PYG{p}{(}\PYG{n}{c} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}111111111111111\PYGZdq{}}\PYG{p}{)} \PYG{k}{then}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{else}
        \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}0\PYGZsq{}}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{diff\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{n}{d1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
      \PYG{n}{d2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1}\PYG{p}{;}
      \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{d1} \PYG{k}{and} \PYG{p}{(}\PYG{k}{not} \PYG{n}{d2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{sw\PYGZus{}out} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{s}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

プロジェクト名 vhdl12

vhdl12.vhd

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{library} \PYG{n+nn}{ieee}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}1164.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}arith.}\PYG{k}{all}\PYG{p}{;}
\PYG{k}{use} \PYG{n+nn}{ieee.std\PYGZus{}logic\PYGZus{}unsigned.}\PYG{k}{all}\PYG{p}{;}

\PYG{k}{entity} \PYG{n+nc}{vhdl12} \PYG{k}{is}
  \PYG{k}{port} \PYG{p}{(}
    \PYG{n}{gclk0} \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw1}   \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{sw2}   \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led1}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led2}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
    \PYG{n}{led3}  \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
  \PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{vhdl12}\PYG{p}{;}

\PYG{k}{architecture} \PYG{n+nc}{rtl} \PYG{k}{of} \PYG{n+nc}{vhdl12} \PYG{k}{is}
  \PYG{k}{component} \PYG{n+nc}{swfilter}
    \PYG{k}{port} \PYG{p}{(}
      \PYG{n}{gclk0}  \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sw}     \PYG{o}{:} \PYG{k}{in} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
      \PYG{n}{sw\PYGZus{}out} \PYG{o}{:} \PYG{k}{out} \PYG{k+kt}{std\PYGZus{}logic}
    \PYG{p}{)}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{component}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{sw1d} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{sw2d} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic}\PYG{p}{;}

  \PYG{k}{type} \PYG{n}{LED\PYGZus{}STAT} \PYG{k}{is} \PYG{p}{(}\PYG{n}{P\PYGZus{}LED1}\PYG{p}{,} \PYG{n}{P\PYGZus{}LED2}\PYG{p}{,} \PYG{n}{P\PYGZus{}LED3}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{signal} \PYG{n}{lstat} \PYG{o}{:} \PYG{n}{LED\PYGZus{}STAT}\PYG{p}{;}

  \PYG{k}{signal} \PYG{n}{led} \PYG{o}{:} \PYG{k+kt}{std\PYGZus{}logic\PYGZus{}vector} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{k}{downto} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{begin}
  \PYG{n}{sw1\PYGZus{}filter} \PYG{o}{:} \PYG{n}{swfilter}
    \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw}     \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw1}\PYG{p}{,}
      \PYG{n}{sw\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw1d}
    \PYG{p}{)}\PYG{p}{;}

  \PYG{n}{sw2\PYGZus{}filter} \PYG{o}{:} \PYG{n}{swfilter}
    \PYG{k}{port} \PYG{k}{map} \PYG{p}{(}
      \PYG{n}{gclk0}  \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{gclk0}\PYG{p}{,}
      \PYG{n}{sw}     \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2}\PYG{p}{,}
      \PYG{n}{sw\PYGZus{}out} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{sw2d}
    \PYG{p}{)}\PYG{p}{;}

  \PYG{n}{stat\PYGZus{}proc} \PYG{o}{:} \PYG{k}{process} \PYG{p}{(}\PYG{n}{gclk0}\PYG{p}{)}
  \PYG{k}{begin}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{gclk0}\PYG{n+na}{\PYGZsq{}event} \PYG{k}{and} \PYG{n}{gclk0} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
      \PYG{k}{case} \PYG{n}{lstat} \PYG{k}{is}
        \PYG{k}{when} \PYG{n}{P\PYGZus{}LED1} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
          \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw2d} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
            \PYG{n}{lstat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{P\PYGZus{}LED2}\PYG{p}{;}
          \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
          \PYG{n}{led} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}001\PYGZdq{}}\PYG{p}{;}

        \PYG{k}{when} \PYG{n}{P\PYGZus{}LED2} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
          \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw1d} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
            \PYG{n}{lstat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{P\PYGZus{}LED1}\PYG{p}{;}
          \PYG{k}{elsif} \PYG{p}{(}\PYG{n}{sw2d} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
            \PYG{n}{lstat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{P\PYGZus{}LED3}\PYG{p}{;}
          \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
          \PYG{n}{led} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}010\PYGZdq{}}\PYG{p}{;}

        \PYG{k}{when} \PYG{n}{P\PYGZus{}LED3} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
          \PYG{k}{if} \PYG{p}{(}\PYG{n}{sw1d} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}1\PYGZsq{}}\PYG{p}{)} \PYG{k}{then}
            \PYG{n}{lstat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{P\PYGZus{}LED2}\PYG{p}{;}
          \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
          \PYG{n}{led} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}100\PYGZdq{}}\PYG{p}{;}

        \PYG{k}{when} \PYG{k}{others} \PYG{o}{=}\PYG{o}{\PYGZgt{}}
          \PYG{n}{lstat} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{P\PYGZus{}LED1}\PYG{p}{;}
          \PYG{n}{led} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}111\PYGZdq{}}\PYG{p}{;}
      \PYG{k}{end} \PYG{k}{case}\PYG{p}{;}
    \PYG{k}{end} \PYG{k}{if}\PYG{p}{;}
  \PYG{k}{end} \PYG{k}{process}\PYG{p}{;}

  \PYG{n}{led1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{led} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led2} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{led} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{led3} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k}{not} \PYG{n}{led} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end} \PYG{n+nc}{rtl}\PYG{p}{;}
\end{sphinxVerbatim}

case 文とは関係ありませんが、swfilter は sw にスイッチからの信号を接続し、sw out にチャタリング除去後の信号を出力する回路ブロックです。


\section{ストップウォッチ}
\label{\detokenize{05_try:id30}}
1/100 秒単位のストップウォッチを実装する。

表示は４桁の７セグ LED で行い、１０進数のカウントで、99.99 秒までカウントできること。


\subsection{課題：最小限の構成}
\label{\detokenize{05_try:id31}}
ラップ・スプリット機能の無いストップウォッチを実装する。

操作は２つのスイッチで行う。
\begin{description}
\item[{スタート・ストップスイッチ}] \leavevmode
往復させる毎にカウント動作とストップを切り替える。

カウント動作中にスタート・ストップスイッチを往復させてストップした後、再度スイッチを往復させると、続きからカウント動作を行う。

\item[{リセットスイッチ}] \leavevmode
往復させるとカウントしていた値をクリアする。

カウント動作中にリセットスイッチを往復させた場合の動作は定義しない (どのように動作してもよい) 。

\end{description}

99.99 秒の次のカウントは未定義 (どのように動作してもよい) 。


\subsubsection{ヒント}
\label{\detokenize{05_try:id32}}
vhdl11b に 10 進カウンタ counter10 、7 セグ LED への変換を行う ledconv がひとつずつあって 1 桁の 10 進カウンタができている。vhdl22 の要領で、これを 2 組、3 組、4 組と増やしていき、4 桁の 10 進カウンタを作るのがよい。いきなり 4 桁に挑戦しても躓くことが多い。

1 秒毎にカウントしているので、これを 1/100 毎にカウントするとよい。

スイッチの入力には、vhdl12 のチャタリング除去回路 swfilter が応用できる。

スタート・ストップの切り替えは vhdl10 が応用できる。

今カウント中なのか止まっているのか、判定する signal を作って制御する。ついでにそれを LED に表示するとわかりやすい。

お試しで signal を作るのにためらいは要らない。それを LED に表示しても誰もとがめない。

時々、作った VHDL ファイルを別名でとっておくと良い。内容が把握できなくなったときは、良くない方向に進んでいる可能性が高いので、前の状態からやり直してみる勇気も必要。


\subsection{課題：応用}
\label{\detokenize{05_try:id33}}
ラップ、またはスプリット、または両方の機能のついたストップウォッチを実装する。

操作は２つのスイッチで行う。
\begin{description}
\item[{スタート・ストップスイッチ}] \leavevmode
往復させる毎にカウント動作とストップを切り替える。

カウント動作中にスタート・ストップスイッチを往復させてストップした後、再度スイッチを往復させた場合、続きからカウント動作を行う。

\item[{ラップ/スプリット・リセットスイッチ}] \leavevmode
往復させたときの動作状況に合わせて、このスイッチの動作も変化する。

カウントがストップしている時に往復させるとリセット動作として、カウントしていた値をクリアする。

カウント動作中に往復させるとスプリット状態に移る。表示している値は止めるが、カウント動作は継続する。

スプリット状態で再度往復させると、スプリット状態が解除され、カウントしている値の表示を再開する。

スプリット状態でスタート・ストップスイッチを往復させると、表示している値は維持したまま、カウント動作を止める。

スプリット状態 \(\rightarrow\) カウント停止からこのこのスイッチを往復させると、カウントがストップした値を表示する（スプリット状態が解除される）。

この状態でもう一度このスイッチを往復させると、カウントはクリアする (リセット) その前にスタートのスイッチを往復させると、その値からカウントを再開する。

ラップの場合、ボタンを往復させると表示している値をとめ、カウントは０から再開する。

ラップ機能、スプリット機能を両方実装する場合は、スイッチの一つをモードの切り替えに割り振る。

\end{description}

99.99 秒の次のカウントは00.00 秒とする。


\subsubsection{ヒント}
\label{\detokenize{05_try:id34}}
現在どの状況にいるのかを保持する signal を作り、状態遷移を応用すると良い。

また状況を LED に表示すると良い。


\subsection{その他課題}
\label{\detokenize{05_try:id35}}
タイマを作成する。

表示は、上位２桁が「分」、下位２桁が「秒」とする。

第一段階は、決められた時間 (たとえば３分など) のカウントダウンを行う。０までカウントダウンが完了したらそこで停止する。

リセットするとカウントする時間をリロードする。

第二段階は、カウントする時間を２つから選べるようにする (たとえば３分と５分) 。

最後は、任意の時間を設定できるようにする。


\chapter{付録}
\label{\detokenize{06_appendix:id1}}\label{\detokenize{06_appendix::doc}}

\section{参考情報}
\label{\detokenize{06_appendix:id2}}
VHDL Language Reference Manual
\begin{quote}

言語の規格

\sphinxurl{http://ieeexplore.ieee.org/xpl/freeabs} all.jsp?reload=true\&arnumber=4772740
\end{quote}

VHDL によるハードウェア設計入門
\begin{quote}

CQ 出版/ 長谷川裕恭著
\end{quote}

HDL サンプル記述集
\begin{quote}

CQ 出版
\end{quote}

トランジスタ技術 SPECIAL No. 79 初歩のHDL 設計学習帳
\begin{quote}

CQ 出版
\end{quote}

トランジスタ技術 SPECIAL for フレッシャーズ No. 105 ロジック回路設計はじめの一歩
\begin{quote}

CQ 出版
\end{quote}

例題で学ぶ論理回路設計
\begin{quote}

森北出版/ 富川武彦著
\end{quote}

ディジタルコンピューティングシステム
\begin{quote}

昭晃堂/ 亀山充隆著
\end{quote}



\renewcommand{\indexname}{索引}
\printindex
\end{document}