<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="ja">
<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" type="text/css" href="style.css" />
<link rel="next" title="付録" href="06_appendix.html"><link rel="prev" title="VHDL" href="04_vhdl.html">  <meta name="generator" content="Re:VIEW" />
  <title>演習 | Text of reconfigurable device</title>
</head>
<body>
  <div class="book">
    <nav class="side-content">
      <h1>Text of reconfigurable device</h1>
      <ul class="book-toc">
<li><a href="index.html">TOP</a></li>
<li><a href="./01_introduction.html">1 はじめに</a></li>
<li><a href="./02_stopwatch.html">2 ストップウォッチについて</a></li>
<li><a href="./03_fpga.html">3 FPGA について</a></li>
<li><a href="./04_vhdl.html">4 VHDL</a></li>
<li><a href="./05_try.html">5 演習</a></li>
<li><a href="./06_appendix.html">付録</a></li>
</ul>
      <p class="review-signature">powered by <a href="http://reviewml.org/">Re:VIEW</a></p>
    </nav>
    <div class="book-body">
      <header>
      </header>
      <div class="book-page">
        <h1><a id="h5"></a><span class="secno">第5章　</span>演習</h1>

<h2><a id="h5-1"></a><span class="secno">5.1　</span>注意事項</h2>
<p>- 開発環境 Quatus II のプロジェクトは、実習項目毎に作り直してください。流用するとトラブルの元になります。- Quatus II の中で日本語を入力するのは避けましょう。こちらもトラブルの元になります。</p>

<h2><a id="h5-2"></a><span class="secno">5.2　</span>論理演算</h2>

<h3><a id="h5-2-1"></a>演習</h3>
<p>プロジェクト名 vhdl01</p>
<p>スイッチ入力に対して論理演算を行い、結果を LED に出力します。</p>
<p>.. literalinclude:: sources/vhdl01.vhd:language: vhdl</p>
<p>このコードで出力される回路は図のようなものになります。</p>
<div id="figure06" class="image">
<img src="../source/figure/figure06.png" alt="" />
<p class="caption">
図5.1: 
</p>
</div>
<p>スイッチは基板奥の方 (７セグ LED 側) に倒すと H 、手前で L のレベルになります。LED に対してはデバイスから H を与えると消灯、L を与えると点灯します。たとえば led1 はスイッチ１番を奥に倒すと消灯、手前に倒すと点灯します。led5 は逆の点灯の仕方になります。</p>

<h2><a id="h5-3"></a><span class="secno">5.3　</span>数値演算</h2>

<h3><a id="h5-3-1"></a>演習</h3>
<p>プロジェクト名 vhdl02</p>
<p>スイッチ入力に対して数値演算を行い、LED に表示します。</p>
<p>.. literalinclude:: sources/vhdl02.vhd:language: vhdl</p>
<p>スイッチの上位 (基板上左側) ４ビットと下位 (右側) ４ビットの演算を行います。LED の上位に加算の結果、下位に減算の結果が２進数で表示されます。</p>
<p>たとえばスイッチを８から１まで、10100001  (1=ON, 0=OFF) とした場合、結果 (= LED の点灯パターン) は 10011011 となります。</p>
<p>また７セグ LED にも結果を表示します。７セグ LED は 0 ～ 9 までの表示を行います。</p>
<div id="figure07" class="image">
<img src="../source/figure/figure07.png" alt="" />
<p class="caption">
図5.2: 
</p>
</div>
<div class="note">
<p>符号無し 4 ビット演算です。</p>
<p>このコードでは、10 以上の数値 ( 具体的には 0 ～ 9 以外 ) は ７セグ LED の表示は E になります。</p>
</div>

<h2><a id="h5-4"></a><span class="secno">5.4　</span>条件分岐 when ～ else ～</h2>

<h3><a id="h5-4-1"></a>演習</h3>
<p>プロジェクト名 vhdl03</p>
<p>条件分岐の書き方の一つ、when ～ else ～ の例です。</p>
<p>.. literalinclude:: sources/vhdl03.vhd:language: vhdl</p>
<p>sw8 を H レベルにしておくと、LED1 は sw2 の操作に従って点灯します。</p>
<p>sw8 が L レベルの場合は、LED1 は sw1 の操作に従って点灯します。</p>
<p>このコードから生成される回路のイメージは次の図の通りです。</p>
<div id="figure08" class="image">
<img src="../source/figure/figure08.png" alt="" />
<p class="caption">
図5.3: 
</p>
</div>
<p>この記述ではいくつでも分岐させることができます。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">ans &lt;= x1 when (y1 = '1')
  else x2 when (y2 = '1')
  else x3 when (y3 = '1')
  else x4 when (y4 = '1')
  else x5;
</pre>
</div>
<p>ただし、判定は記述した順番に行われます。この例でたとえば y1 ～ y4 全てが 1 だった場合、y1 の条件が採用されます (プライオリティエンコーダ＝選択肢に優先順位のあるセレクタ) 。</p>

<h2><a id="h5-5"></a><span class="secno">5.5　</span>条件分岐 with ～ select ～ when ～</h2>

<h3><a id="h5-5-1"></a>演習</h3>
<p>プロジェクト名 vhdl04</p>
<p>条件分岐の書き方の一つ、with ～ select ～ when ～ の例です。</p>
<p>.. literalinclude:: sources/vhdl04.vhd:language: vhdl</p>
<p>sw7 と sw8 の設定により、LED の点滅を制御できるスイッチを切り替えられる回路です。</p>
<p>このコードから生成される回路のイメージは次の通りです。</p>
<div id="figure09" class="image">
<img src="../source/figure/figure09.png" alt="" />
<p class="caption">
図5.4: 
</p>
</div>
<p>中央のブロックはセレクタで、上から入力される値がブロック中の値と一致すると、その箇所の信号が出力されます。</p>
<p>選択肢に優先順位がある場合は when ～ else ～、ない場合は with ～ select ～ when ～ を使います。</p>

<h2><a id="h5-6"></a><span class="secno">5.6　</span>process 文</h2>
<p>AND、OR、NOT などの組み合わせ回路や単純な条件分岐であればこれまでの内容で対応できますが、フリップフロップなどを組み合わせた順序回路を記述するには、process 文を使用します。</p>
<div class="tip">
<p>フリップフロップ専用の記述ではありませんが、フリップフロップを使用する箇所のみ process 文を使うようにしていると、慣れていないうちはトラブルを避けやすくなります。</p>
</div>
<p>基本的な構成は以下の通りです。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">LABEL: process (SENSITIVITY-LIST)
begin
  ～ EXPRESSION ～
end process;
</pre>
</div>
<p>ラベル(LABEL) を付加するかどうかは任意ですが、識別のために固有の名前をつけておくのがよいでしょう。</p>
<p>センシティビティリスト(SENSITIVITY-LIST) は、この process 文を動作させるトリガになる信号のリストを記述します。</p>
<div class="note">
<p> センシティビティリストに書いた信号は「トリガ」と書きましたが、その信号が変化した時に必ず process 文の内容が実行されるという話ではなく、その信号が変化したときに、process 文の一番最初の if ～ then ～ elsif ～ else ～ end if の条件で動作する、という点を覚えておきましょう。</p>
</div>
<p>信号名はカンマで区切ります。</p>
<p>式(EXPRESSION) の部分には実際の動作を記述します。ただし条件分岐は、これまでの when ～ else ～ や with ～ select ～ when ～ は使用できません。後ほどでてくる if 文や case 文を使用します (逆に if 文や case 文は process 文の外では使用できません) 。</p>
<p>.. csv-table:: 組み合わせ:header-rows: 1</p>
<p>&quot;process 文の&quot;, &quot;when ～ else ～&quot;, &quot;with ～ select ～ when ～&quot;, &quot;if ～ elsif ～ endif&quot;, &quot;case ～ end case&quot;&quot;外&quot;, &quot;○&quot;, &quot;○&quot;, &quot;×&quot;, &quot;×&quot;&quot;中&quot;, &quot;×&quot;, &quot;×&quot;, &quot;○&quot;, &quot;○&quot;</p>

<h2><a id="h5-7"></a><span class="secno">5.7　</span>フリップフロップの基本と if 文</h2>
<p>フリップフロップは主に D 型、SR 型、JK 型、T 型があります。これらを VHDL で記述するときは一般に process 文を使用します。</p>
<p>フリップフロップのリセットが非同期式の場合、D フリップフロップは以下のように記述します。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">D_FF: process (reset, clock)
begin
  if (reset = '1') then
    q &lt;= '0';
  elsif (clock'event and clock = '1') then
    q &lt;= d;
  end if;
end process;
</pre>
</div>
<p>この例では、すべての信号は std_logic で定義されているとします。</p>
<p>入力データは信号は d 、出力データ信号は q としています。</p>
<p>reset に H レベルの信号を与えるとリセット動作として、q を L レベルにセットしています。</p>
<p>クロック信号 clock が H へ変化すると、q へ d を代入します。</p>
<div id="figure12" class="image">
<img src="../source/figure/figure12.png" alt="" />
<p class="caption">
図5.5: 
</p>
</div>
<p>動作例を以下に示します。</p>
<div id="figure10" class="image">
<img src="../source/figure/figure10.png" alt="" />
<p class="caption">
図5.6: 
</p>
</div>
<p>a の期間では reset = '1' が成り立つので q &lt;= '0' が実行され続けます。</p>
<p>b のタイミングでは clock'event and clock = '1' が成り立ちます。これは、clock が変化したこと (clock'event) と clock = '1' の組み合わせで、clock が 0 から 1 に変化したときに成り立つ、という記述の仕方です。このとき q &lt;= d が実行されます。d が 1 なので最終的には q は 1 になります。</p>
<p>c のタイミングも b のタイミング同様、clock が 0 から 1 に変化したことが成り立っています。q には d の値 0 が代入されます。</p>
<p>d の期間では e や f のタイミングで clock'event が成り立っていますが、if 文 (後述) で reset = '1' が先に記述されているため、e 、f は無視され、q には 0 が出力され続けます。</p>
<p>ちなみに FPGA が起動したとき、フリップフロップの値が H 、L どちらになっているかは決まっていません。そのため図で q はリセットがかかるまではどちらの値かわかりません (不定) 。</p>

<h3><a id="h5-7-1"></a>シミュレーション</h3>
<p>順序回路の動作確認にはシミュレータが役に立ちます。ここでシミュレーションにより上記の動作を確認します。</p>
<p>D:\Altera\(学籍番号) に vhdl20 というフォルダを作ります。</p>
<p>Web ブラウザで http://vhdl.cottonrose.jp/2016/ を開き、vhdl20.vhd をダウンロードし、先ほどのフォルダにダウンロードします。</p>
<div class="note">
<p>ダウンロードしたファイルが読み取り専用になっていることがあります。</p>
</div>
<p>別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。</p>
<p>34 ページまで実行すると、上記のような波形が見られます (波形の赤いラインは不定を表します)。</p>
<div class="note">
<p>自分自身への代入について</p>
<p>process 文の中の if 文の中で、clock'event and clock = \'1\' の条件の中では、宣言されている signal や variable に自分自身を代入できます。</p>
<p>例えば、a &lt;= a; はこのままでは無意味なコードですが、正常なものです。これは、この代入動作がクロックの変化点のみ行われるのがポイントです。</p>
<p>これを応用すると、a &lt;= not a; であればクロックの変化点事に反転、a &lt;= a + 1; であればカウントアップしていく動きになります。</p>
<p>これが process 文の外、clock'event and clock = '1' の外では、エラーになるか、予測できない動作になります。エラーにならなかった場合、例えば a &lt;= not a; はデバイスの限界速度で反転を繰り返す信号を生成しますが、スイッチ動作が多すぎて電流消費、発熱から、何が起きるかわかりません。</p>
</div>

<h3><a id="h5-7-2"></a>同期、非同期</h3>
<p>「非同期」動作は、クロックによらず動作する箇所、「同期」動作はクロックの変化点に合わせて動作することを示しています。</p>
<p>先ほどのサンプルでは、リセットは非同期動作 (特にこの場合は「非同期リセット」とも呼ばれる) 、データの保持は同期動作としています。</p>
<div class="note">
<p>データをクロックに同期して保持するものを一般にフリップフロップ、同期せずに保持するものをラッチと呼びます。</p>
<p>これは「ディジタルコンピューティングシステム」p54 に書かれていることと逆ですが、会社などの組織毎に異なる場合があるので注意が必要です。</p>
</div>
<div class="warning">
<p>FPGA に実装する回路において、一般にラッチは使用するべきではないとされています。</p>
<p>フリップフロップを使った方が動作が予測しやすいため、デバイス自体にフリップフロップが組み込まれています。それに対しラッチは大規模回路では動作の予測が難しく、バグの元になりやすいため、です。</p>
<p>慣れないうちは、できる限りすべてのフリップフロップは同じクロックで動作するようにし、動作を始める前にはすべて非同期リセットを行うように組むと失敗が少なくなります。</p>
</div>
<div class="note">
<p>「ディジタル回路」は信号レベル (縦軸) を離散的に扱います。「同期回路」は時間軸を離散的に扱うための手法と考えられます。「非同期回路」は時間軸に不確定な要因を持つことになるため、動作の安定性に影響します。</p>
<p>この授業の実習では、その実習で使用するすべてのフリップフロップは同じクロックで動作させるようにします。</p>
<p>これらを守るためには、上の D フリップフロップの例のようなセンシティビティリスト (信号名は回路に合わせる) 、if 文の構成 (非同期リセットとクロックの動作しかなく、それ以上はその if 、elsif の中に書き足していく) を基本にしていきます。</p>
</div>

<h3><a id="h5-7-3"></a>if 文</h3>
<p>条件分岐の基本的なもので、基本的な形は以下の通りです。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">if (CONDITION) then
  ～ EXPRESSION ～
end if;
</pre>
</div>
<p>条件(CONDITION) が真であれば、処理(EXPRESSION) が実行されます。複数の条件ごとに処理を分ける場合は以下のようになります。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">if (CONDITION_A) then
  ～ EXPRESSION_A ～
elsif (CONDITION_B) then
  ～ EXPRESSION_B ～
elsif (CONDITION_C) then
  ～ EXPRESSION_C ～
else
  ～ EXPRESSION_OTHER ～
end if;
</pre>
</div>
<p>条件 A (CONDITION-A) が真であれば処理 A (EXPRESSION-A) を実行、それ以外で条件 B (CONDITION-B) が真であれば処理 B (EXPRESSION-B) 、それ以外で条件 C (CONDITION-C) が真であれば処理 C (EXPRESSION-C)、それ以外ではその他の処理(EXPRESSION-OTHERS) を実行します。</p>
<div class="note">
<p>一般のプログラミング言語と異なり、「else if」ではなく「elsif」と書きます。</p>
</div>
<p>条件の書き方は、たとえば一致判定では</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">reset = '1'
</pre>
</div>
<p>不一致判定は</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">reset /= '0'
</pre>
</div>
<p>数値の大小の比較では、</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">count &gt;= &quot;1010&quot;
</pre>
</div>
<p>となります。</p>
<p>条件は複数組み合わせることができ、そのときは and 、or 、not も使用できます。</p>
<p>たとえば</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">a = '1' and b = '0'
</pre>
</div>
<p>とすれば、２つの条件が満たされた場合、と判定されます。クロックの変化点での動作、つまり同期動作について括る場合の条件は、</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">clock'event and clock = '1'
</pre>
</div>
<p>が一般的となります。これは clock の変化点と、clock が H という２つの条件の AND となります。</p>
<div class="note">
<p>上記のような、クロックの変化点での動作の記述は、一つの if 文で複数書いても文法上は問題ありませんが、実際のデバイス上でそのような動作は行うことができません。</p>
</div>
<p>一般に process 文の最初の if 文の構成は最大で</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (set, reset, clock)
begin
  if (reset = '1') then
    ～
  elsif (set = '1') then
    ～
  elsif (clock'event and clock = '1') then
    ～
  end if ;
end process;
</pre>
</div>
<p>となります。</p>
<p>リセット時、セット (プリセット) 時、その他通常動作時を同じレベルで設定しています。</p>
<p>以下の書き方は許容されますが、理解できていないうちは行うべきではありません。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (clock)
begin
  if (clock'event and clock = '1') then
    ～
  end if;
end process;
process (clock)
begin
  if (clock'event and clock = '0') then
    ～
  end if;
end process;
</pre>
</div>
<p>同じクロックで動作する書き方ですが、1 = クロックの立ち上がりと 0 = クロックの立ち下がりが混在しています。この２つの process 文の間でデータのやりとりがあるとき、デバイス上での動作条件が厳しくなります。</p>
<p>以下の書き方は実機には基本的には組み込めません。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (clock)
begin
  if (clock'event and clock = '1') then
    ～
  elsif (clock'event and clock = '0') then
    ～
  end if;
end process;
</pre>
</div>
<p>同じ process 文内で、同じクロックの 1 = クロックの立ち上がりと 0 = クロックの立ち下がりが混在しています。同じ signal に対してこのような動作は指示できません。それぞれの処理に異なる signal を入れれば組み込むことはできますが、一つ前の例と同様使うべきではありません。</p>

<h3><a id="h5-7-4"></a>マルチソース</h3>
<p>HDL では、基本的に全ての行が、常に「同時」に動作していると考える必要があります。この点が、ソースコードを逐次解釈していくソフトウェアと大きく異なる点です。</p>
<p>これにより、signal や port への値の代入の仕方に制限があります。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">architecture rtl of test is
  signal a : std_logic;
begin
  a &lt;= '0';
  a &lt;= '1';
end rtl;
</pre>
</div>
<p>ソフトウェアであればこの場合、a に 0 が代入された後でさらに a に 1 が代入されます。しかし HDL の場合、0 と 1 の代入は同時に行おうとし、論理合成の段階でエラーとなります (エラーメッセージには multi source という言葉が含まれます) 。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">entity x is
  port (
    d1  : in std_logic;
    d2  : in std_logic;
    clk : in std_logic;
    q   : out std_logic
  ) ;
end x;

architecture rtl of x is
  signal a : std_logic;
begin
  a_proc : process (clk)
  begin
    if (clk'event and clk = '1') then
      a &lt;= d1;
    end if;
  end process;

  b_proc : process (clk)
  begin
    if (clk'event and clk = '1') then
      a &lt;= d2;
    end if;
  end process;

  q &lt;= a;

end rtl;
</pre>
</div>
<p>別々の process 文で動作させていても、同じ signal に代入しようとしているため、両方の条件が必ず衝突しない書き方出ない限り論理合成でエラーになります (そしてそのように書いたとしても不具合の修正なので書き換えているうちに条件が崩れ multi source のエラーになりやすいです) 。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">entity x is
  port (
    d1  : in std_logic;
    d2  : in std_logic;
    clk : in std_logic;
    q   : out std_logic
  ) ;
end x ;

architecture rtl of x is
  signal a : std_logic;
begin
  a proc : process (clk)
  begin
    if (clk'event and clk = '1') then
      a &lt;= d1;
    end if;
  end process;

  a &lt;= d2;
  q &lt;= a;

end rtl;
</pre>
</div>
<p>このような process 文での順序回路と、通常の組み合わせ回路でも同様です。</p>

<h3><a id="h5-7-5"></a>process 文、if 文によるフリップフロップの記述のお約束</h3>
<p>この教科書ではこの先順序回路を多く使用します。その際、後々のトラブルを避けるため、以下のような書き方を避けることをおすすめします。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (reset, clock, a, b)
begin
  if (reset = '1') then
    ～ RESET-PROCEDURE ～
  elsif (clock'event and clock = '1' and a = '1') then
    ～ PROCEDURE-A ～
  elsif (clock'event and clock = '1' and b = '1') then
    ～ PROCEDURE-B ～
  end if;
end process;
</pre>
</div>
<p>どうやら、リセット処理(RESET-PROCEDURE)、クロックに同期した上で a が 1 の時の処理(PROCEDURE-A)、クロックに同期した上で b が 1 の時の処理(PROCEDURE-B)を行いたいらしい。</p>
<p>このような場合は以下のように、クロックによる動作と論理を分離して記述すると良いでしょう。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (reset , clock)
begin
  if (reset = '1') then
    ～ RESET PROCEDURE ～
  elsif (clock'event and clock = '1') then
    if (a = '1') then
      ～ PROCEDURE A ～
    elsif (b = '1') then
      ～ PROCEDURE B ～
    end if;
  end if;
end process ;
</pre>
</div>
<p>クロックの条件に追加で書いていると、この授業のレベルではその箇所でミスをしやすくなります。</p>
<p>またクロックの条件と分離することで、他へのコピー＆ペーストでのミスも減ります。</p>
<p>このほか、以下の箇所で代入を行っても、意図した動作にならない可能性が高いです。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (reset , clock)
begin
  if (reset = '1') then
    ～ RESET PROCEDURE ～
  elsif (clock'event and clock = '1') then
    ～ MAIN PROCEDURE ～
  end if;
  a &lt;= b;
end process;
</pre>
</div>
<p>a へ b を代入していますが、この位置ではセンシティビティリストに入る reset と clock の条件を無視した位置にあるため、どのような動作になるか保証できません。</p>
<p>process 文の外か、if 文の中に入れましょう。</p>

<h3><a id="h5-7-6"></a>演習</h3>
<p>プロジェクト名 vhdl05</p>
<p>D フリップフロップを作る</p>
<p>.. literalinclude:: sources/vhdl05.vhd:language: vhdl</p>
<p>ヒント</p>
<p>&quot;--&quot; (マイナス２個) 以降は改行までコメントとして無視されます。</p>
<p>この例では、sw1 をデータ入力、sw2 をクロック、sw3 をリセットとして使用しています。</p>
<p>シグナル d を D フリップフロップの実態という意味で定義しています。</p>
<p>sw3 を H にすると、フリップフロップをリセットします。</p>
<p>sw2 が H に変化したタイミング (立ち上がりエッジ) で、sw1 の内容を d へ代入します。そのほかのタイミングでは sw1 の変化の影響を受けません。</p>
<p>process 文内の処理は sw2 と sw3 の変化でしか行われないため、センシティビティリストには sw2 と sw3 しか書いていません。</p>
<p>led1 には d の内容を出力しています。</p>
<div id="figure13" class="image">
<img src="../source/figure/figure13.png" alt="" />
<p class="caption">
図5.7: 
</p>
</div>
<p>動作確認</p>
<ol>
<li>sw1、sw2、sw3 をすべて OFF にする。</li>
<li>まず sw3 を ON → OFF して、リセットする。</li>
<li>sw2 を ON → OFF して、led1 が変化しないことを確認する。 (入力データ sw1 が OFF なので、OFF のデータを改めてサンプルするだけ)</li>
<li>sw1 を ON にする。</li>
<li>sw2 を ON → OFF して、 led1 が変化することを確認する。</li>
<li>sw1 を OFF にしても led1 が変化しないことを確認する。</li>
<li>sw2 を ON → OFF して、 led1 が変化することを確認する。</li>
</ol>

<h3><a id="h5-7-7"></a>課題</h3>
<p>プロジェクト名 vhdl06</p>
<p>下記のソースコードに追記して、JK フリップフロップを作れ</p>
<p>.. literalinclude:: sources/vhdl06.vhd:language: vhdl</p>
<p>２箇所の&quot;put code below&quot; から&quot;put code above&quot; の間にコードを書いてください。</p>
<p>ソースコード中で指定しているようなスイッチのアサインで、JK フリップフロップを作成してください。</p>
<div id="figure14" class="image">
<img src="../source/figure/figure14.png" alt="" />
<p class="caption">
図5.8: 
</p>
</div>
<div id="truth" class="table">
<p class="caption">表5.1: 真理値表</p>
<table>
<tr><th>sw2 (clock)</th><th>sw1(J)</th><th>sw3(K)</th><th>led1(Q → jk)</th></tr>
<tr><td>↑以外</td><td>X</td><td>X</td><td>維持</td></tr>
<tr><td>↑</td><td>0</td><td>0</td><td>維持</td></tr>
<tr><td>↑</td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>↑</td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>↑</td><td>1</td><td>1</td><td>反転</td></tr>
</table>
</div>
<div class="note">
<p>「維持」は、自分自身を代入することで行えます。</p>
</div>
<p>動作確認は以下の通り行います。</p>
<ol>
<li>sw1 ～ sw4 を OFF にする。</li>
<li>sw4 を ON → OFF として、リセットする (led1 が点灯する) 。</li>
<li>sw1 を ON → OFF として、led1 が変化しないことを確認する (J だけ動かしている) 。</li>
<li>sw3 を ON → OFF として、led1 が変化しないことを確認する (K だけ動かしている) 。</li>
<li>sw1 を ON にし、sw2 を ON → OFF として、led1 が消灯することを確認する。</li>
<li>sw1 を OFF にし、sw2 を ON → OFF としても、led1 が消灯したままであることを確認する。</li>
<li>sw3 を ON にし、sw2 を ON → OFF として、led1 が点灯することを確認する。</li>
<li>sw3 を OFF にし、sw2 を ON → OFF としても、led1 が点灯したままとなることを確認する。</li>
<li>sw1 、sw3 を ON にし、sw2 を ON → OFF として、led1 が消灯することを確認する (注記参照) 。</li>
<li>sw1 、sw3 を ON にしたままで、sw2 を ON → OFF として、led1 が点灯することを確認する (注記参照) 。</li>
</ol>
<div class="note">
<p>最後の２つは、想定通りに動いたり、動かなかったりする。これは後述するチャタリングが原因。</p>
</div>

<h2><a id="h5-8"></a><span class="secno">5.8　</span>カウンタ</h2>
<p>フリップフロップはクロックに合わせて値を保持します。複数ビットのフリップフロップの組み合わせの出力に加算器を接続し、その結果をフリップフロップに戻すことで、次のクロックでは加算後の結果が保持されます。</p>
<p>加える値が１であれば、１ずつ増えていくカウンタとなります。</p>
<div id="figure15" class="image">
<img src="../source/figure/figure15.png" alt="" />
<p class="caption">
図5.9: 
</p>
</div>
<p>プロジェクト名 vhdl07</p>
<p>.. literalinclude:: sources/vhdl07.vhd:language: vhdl</p>
<p>クロックはあらかじめ、32MHz を選択しておきます (JP3、JP4、JP5 のうち JP5 だけショートさせる) 。</p>
<p>カウンタの信号は c で、process 文 count の中でクロックの立ち上がりエッジの度に１を加えます。</p>
<p>c の幅は 25bit なので、0 ～ 33,554,431 までの値を扱うことができます。入力しているクロックが 32MHz なので、約1秒で一周するよう、LED が点灯します。</p>
<p>LED には、上位 8bit のみ表示しています。</p>
<p>この記述では、ソフトウェアの for や while のようなループが書かれていませんが、センシティビティリストの gclk0 の変化 = クロックの変化毎にプロセス文の記述が呼び出されるため、自動的に繰り返し実行されます。</p>

<h2><a id="h5-9"></a><span class="secno">5.9　</span>分周回路と T フリップフロップ</h2>

<h3><a id="h5-9-1"></a>分周回路</h3>
<p>カウンタを応用した回路構成の一つで、元の周波数の整数分の１の周波数を作り出します。</p>
<p>２分周 ( 1/2 の周波数) 、４分周 ( 1/4 の周波数) 、８分周 ( 1/8 の周波数) の例を図に示します。</p>
<div id="figure16" class="image">
<img src="../source/figure/figure16.png" alt="" />
<p class="caption">
図5.10: 
</p>
</div>
<p>２分周を超える場合、作られる信号の形は２つのパターンがあります。</p>
<p>一つは、デューティ比 ( H レベルと L レベルの期間の比) ができるだけ５０：５０になるよう近づけたパターン。</p>
<p>もう一つは、作り出した周期の中で１クロック分だけ H レベルとし、残りは L とするパターン。</p>
<p>通常デバイス内では後者、デバイスの外では前者が使われることが多いです。</p>
<p>４分周の２つめのパターンの例を以下に示します。</p>
<p>プロジェクト名 vhdl08</p>
<p>.. literalinclude:: sources/vhdl08.vhd:language: vhdl</p>
<p>この中で c は１０進数で０～３までカウントし、r にはそのうち３のときだけ '1' がセットされます。その反転による LED の点灯がされるため、gclk0 32MHz で４周期のうち１サイクルだけ点灯することになり、結果として単純に点灯している led2 に比べ led1 が暗くなります。</p>
<div id="figure17" class="image">
<img src="../source/figure/figure17.png" alt="" />
<p class="caption">
図5.11: 
</p>
</div>

<h3><a id="h5-9-2"></a>課題</h3>
<p>プロジェクト名 vhdl09</p>
<p>約１秒周期で led1 の点灯、消灯を繰り返す回路を作れ(約 0.5 秒点灯、約 0.5 秒消灯を繰り返す)</p>
<p>.. literalinclude:: sources/vhdl09.vhd:language: vhdl</p>
<p>分周回路と T フリップフロップ (のような動作) を組み合わせて作成します。基板上、JP5 のジャンパをショートし、gclk0 の周波数を 32MHz に設定します。</p>
<p>2カ所のスペースのうち、一つ目には分周回路、二つ目には T フリップフロップを構成します。</p>
<p>分周回路は、１クロックだけ H レベルを作るような構成にする必要があります。先ほどの分周回路では &quot;11&quot; と比較していたところを、今回は (2^25)-1 、つまり&quot;111111111111111111111111&quot;と比較することになります。このときに r を 1 に、それ以外の値の時は 0 にセットします。</p>
<p>T フリップフロップは単純で、入力信号が 1 であれば反転、0 であればデータを維持します。</p>
<div class="note">
<p>signal 宣言した信号は、その architecture 内でグローバル変数のように働きます。同じ architecture 内にある全ての process 文内から読み出すことができます。</p>
</div>
<p>r は、32MHz を 33,554,431 回カウントする毎に 1 になるため、そのたびに t が反転されます。それを led1 に出力すれば、目的の回路ができあがります。</p>

<h2><a id="h5-10"></a><span class="secno">5.10　</span>積分回路とチャタリング除去</h2>
<p>機械的なスイッチは、切り替えたときに信号の状態が不安定な期間があります。</p>
<div id="figure18" class="image">
<img src="../source/figure/figure18.png" alt="" />
<p class="caption">
図5.12: 
</p>
</div>
<p>この不安定な期間は数 ms 程度続く場合もあります。人間にとっては感知できないほど短い時間ですが、FPGA は動作が十分速いため、この細かい変化を検出し、反応してしまいます。たとえば課題 vhdl06 ではこれにより不安定な動作となっています。</p>
<p>そのため、それを除去する回路を組み込む必要があります。これには積分回路を応用します。</p>
<div id="figure19" class="image">
<img src="../source/figure/figure19.png" alt="" />
<p class="caption">
図5.13: 
</p>
</div>
<p>積分回路は基本的にはカウンタです。入力を単純に加算していきます。これを応用し、H が入力されている間は上限まで加算 (上限まで来たら値を維持) 、一度でも L が来たら値をクリアします。</p>
<p>この応用した回路に、スイッチからの信号を入力します。スイッチを切り替えない期間では、カウンタの値は０か最大のいずれかで安定します。</p>
<p>スイッチを切り替えた時、入力は H と L が激しく切り替わります。応用した回路では入力の H が一定期間維持されると H を出力するよう動作しますので、この「一定期間」が数ミリ秒となるようなカウンタの最大値を設定すれば良いことになります。</p>
<div id="figure20" class="image">
<img src="../source/figure/figure20.png" alt="" />
<p class="caption">
図5.14: 
</p>
</div>
<p>応用回路はたとえば以下のようなソースになります。clock は積分していくサイクル、sw1 がチャタリングのあるスイッチからの入力、r がチャタリング除去後の出力です。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">process (clock)
begin
  if (clock'event and clock = '1') then
    if (sw1 = '0') then
      c &lt;= &quot;000000000000000&quot;;
    elsif (c /= &quot;111111111111111&quot;) and (sw1 = '1')) then
      c &lt;= c + 1;
    end if;

    if (c = &quot;111111111111111&quot;) then
      r &lt;= '1';
    else
      r &lt;= '0';
    end if;
  end if;
end process;
</pre>
</div>
<p>最初の if 文では、カウンタによる積分回路を構成しています。</p>
<p>スイッチを 0 側に倒されたら (sw1 = '0') カウンタの値は即０とします。</p>
<p>スイッチが 1 側に倒されたら (sw1 = '1') 、カウンタがいっぱいでなければ (c /= &quot;111111111111111&quot;、&quot;/=&quot;は&quot;一致していない&quot; の意味) カウントします (c &lt;= c + 1) 。</p>
<p>このカウンタは、スイッチが 1 側に倒されれば、カウンタのビットがすべて１になるまでカウントを続け、0 側に倒されればすぐにすべて０に戻します。</p>
<p>スイッチからの信号が不安定な状態では、少しでも０がくればカウンタも０に戻されますが、十分安定すれば最後までカウントします。</p>
<p>32MHz であれば１周期は約 31ns なので、15bit で 32000 回カウントすれば約１ｍｓになります。スイッチが約１ｍｓ安定すれば、最後までカウントされることになります。</p>
<p>次の if 文では、前のカウンタが最後までカウントされたら１、それ以外は０を出力します。スイッチ入力が安定したことを判定することができます。</p>
<p>このままでは１ｍｓしか対応できないため、チャタリングが除去し切れていないように見える場合はカウンタのビットを追加する必要があります。</p>
<div class="note">
<p>std_logic_vector の桁数が、比較演算子の左右で一致していない場合、正しく比較されない場合があります。思ったように動作しない場合は、桁数も確認してください。</p>
</div>

<h3><a id="h5-10-1"></a>シミュレーション</h3>
<p>チャタリング除去の動作をシミュレーションで確認します。</p>
<p>D:\Altera\(学籍番号) に vhdl21 というフォルダを作ります。</p>
<p>Web ブラウザで http://vhdl.cottonrose.jp/2016/ を開き、vhdl21.vhd をダウンロードし、先ほどのフォルダにダウンロードします。</p>
<div class="note">
<p>ダウンロードしたファイルが読み取り専用になっていることがあります。</p>
</div>
<p>別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。</p>
<p>signal の s_switch が、人間がイメージしているスイッチの ON/OFF です。</p>
<p>sw1 は FPGA からみた入力信号を模擬しています。</p>
<p>r が、チャタリング除去後の信号で、s_switch よりは時間が短いものの、sw1 のような信号のばたつきが無くなっていることが分かります。</p>
<p>シミュレーション完了後、Wave のエリアで signal c に対し右クリック → Radix → Unsigned 、もう一度右クリック → Format → Analog (Automatic) で、チャタリング除去に使用したカウンタの値の変化を違った形で見ることができます。チャタリングが出ているときは、ここでは 1 までしかカウントできず直ぐに 0 に戻されていることが分かります。</p>

<h2><a id="h5-11"></a><span class="secno">5.11　</span>微分回路</h2>
<p>人間や機械からの信号= 遅い信号と高速な内部の回路とのインタフェースをしやすくする回路です。</p>
<p>たとえばスイッチを動かす度に LED の点灯、消灯を切り替えたいとします。タイミングチャートは以下のようなものです。</p>
<div id="figure21" class="image">
<img src="../source/figure/figure21.png" alt="" />
<p class="caption">
図5.15: 
</p>
</div>
<p>スイッチ入力をクロックとして T フリップフロップに入力できれば実現できますが、同期動作ではないためトラブルの原因になりやすく、採用できません。</p>
<p>出力の信号を生成しているフリップフロップのクロックが十分遅ければやはり T フリップフロップで対応できそうですが、今回のボードに限らず通常は MHz 級の動作周波数ですのでそのような動作はできません。</p>
<div id="figure22" class="image">
<img src="../source/figure/figure22.png" alt="" />
<p class="caption">
図5.16: 
</p>
</div>
<p>スイッチ入力の変化点を検出する回路ができれば、T フリップフロップでも望みの動作が可能になります。</p>
<div id="figure23" class="image">
<img src="../source/figure/figure23.png" alt="" />
<p class="caption">
図5.17: 
</p>
</div>
<p>変化点を検出するため、微分回路と呼ばれる回路を使用します。</p>
<div id="figure24" class="image">
<img src="../source/figure/figure24.png" alt="" />
<p class="caption">
図5.18: 
</p>
</div>
<p>原理は簡単で、フリップフロップ２段を通して１クロックずつ遅延した信号の間の特定の差だけを抽出します。</p>
<p>実際の回路は以下のようになります。</p>
<div id="figure25" class="image">
<img src="../source/figure/figure25.png" alt="" />
<p class="caption">
図5.19: 
</p>
</div>

<h3><a id="h5-11-1"></a>演習</h3>
<p>プロジェクト名 vhdl10</p>
<p>スイッチを往復させる毎に LED の点灯、消灯を切り替える回路を作る。</p>
<p>.. literalinclude:: sources/vhdl10.vhd:language: vhdl</p>
<p>diff proc とその直後の s への代入が微分回路になります。</p>

<h2><a id="h5-12"></a><span class="secno">5.12　</span>１０進カウンタ</h2>

<h3><a id="h5-12-1"></a>課題</h3>
<p>プロジェクト名 vhdl11</p>
<p>０～９まで、１秒間に１ずつカウントする、１０進カウンタを作れ。カウント値は９の次は０に戻る。signal r は１秒に１回、１サイクルだけ H レベルになる信号となる。led1 が点滅する場合は誤りがある。</p>
<p>プロセス文 div_proc が１秒を作る。それを利用してプロセス文 cnt_proc 内で signal c で０～９をカウントする。</p>
<p>.. literalinclude:: sources/vhdl11.vhd:language: vhdl</p>
<p>７セグメント LED の点灯パターンはコードの通りになる、LED の配置は図のようになっています。port に L を出力すると、電位差で電流が流れ LED が点灯します。</p>
<div id="figure26" class="image">
<pre class="dummyimage">
</pre>
<p class="caption">
図5.20: 
</p>
</div>

<h2><a id="h5-13"></a><span class="secno">5.13　</span>階層設計</h2>
<p>規模が大きくなってくると、すべてのコードを一つの architecture に書ききることが問題になります。そのためコードを機能ブロック毎に分割し呼び出すことができるようになっています。例を以下に示します。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity Y_child is
  port (
  ～ PORT_DEFINITION(CHILD) ～
  );
end Y child ;

architecture A_Y_child of Y_child is
  ～ SIGNAL_DEFINITION(CHILD) ～
begin
  ～ EXPRESSIONS(CHILD) ～
end A Y chi ld ;


library ieee ;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity X_parent is
  port (
    ～ PORT_DEFINITION(PARENT) ～
  );
end X_parent;

architecture A_X_parent of X_parent is

  component Y_child
    port (
      ～ PORT_DEFINITION(CHILD) ～
    );
  end component;

  ～ SIGNAL_DEFINITION(PARENT) ～

begin

  i_Y_child : Y_child
    port map (
      ～ PORT_CONNECTION(CHILD PARENT) ～
    );

  ～ OTHER_EXPRESSIONS(PARENT) ～

end A_X_parent;
</pre>
</div>
<p>処理を抜き出した、他から呼び出される側の entity は、通常通り作成します。</p>
<p>処理を呼び出す場合は２段階の手続きがあります。</p>
<p>まず architecture から begin までの間で、component 宣言を行います。ここで、呼び出す entity はすべて宣言します。</p>
<p>次に begin の後で、実際に呼び出します。複数個呼び出すこともできますが、その場合は entity 名の前のコロンの前、インスタンス名 (ここでは i_Y_child ) はそれぞれ固有のものにします。</p>

<h3><a id="h5-13-1"></a>演習</h3>
<p>１０進数カウンタに階層化を適用します。</p>
<div class="note">
<p>counter10.vhd と ledconv.vhd は、vhdl11b プロジェクトを作成した後、それぞれ vhdl11b.vhd と同様に file → new → VHDL file で作成します。</p>
</div>
<p>counter10.vhd</p>
<p>.. literalinclude:: sources/counter10.vhd:language: vhdl</p>
<p>c_in は下の桁からの桁上げのリクエストを受け付けるポート、c_out は上の桁への桁上げのリクエストを出力するポートです。</p>
<p>e_in は H レベルが入るとカウントを行うポートです。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">if ((e_in = '1') and (c_in = '1')) then
</pre>
</div>
<p>の箇所は、これまでのカウンタのソースでの r = '1' に相当します。</p>
<p>ledconv.vhd</p>
<p>.. literalinclude:: sources/ledconv.vhd:language: vhdl</p>
<p>sledxa から sledxg は７セグ LED の各端子に相当します。vhdl11b では１桁のみ使うため、sled1a ～ sled1g と対応させています。これが４桁になる場合、ledconv を４個用意し、sled1a ～ sled1g から sled4a ～ sled4g までに対応させます。</p>
<p>プロジェクト名 vhdl11b</p>
<p>vhdl11b.vhd</p>
<p>.. literalinclude:: sources/vhdl11b.vhd:language: vhdl</p>
<p>この状態で、ソースコードの関係は以下のようになります。</p>
<div id="figure27" class="image">
<pre class="dummyimage">
</pre>
<p class="caption">
図5.21: 
</p>
</div>
<p>counter10 を呼び出しているときのキーワード &quot;i_counter1&quot; や ledconv に対する &quot;i_conv1&quot; がインスタンス名となります。固有のインスタンス名をつけることで、同じ回路ブロックを複数回呼び出すことができます。</p>
<p>ポートの接続はこのコードのように、左辺に呼び出される回路のポート名、=&gt; をはさんで右辺に呼び出し側の port 名または signal 名を書き、カンマで区切ります。カンマは区切りなので最後の接続の後には書きません。</p>

<h3><a id="h5-13-2"></a>シミュレーション &amp; 演習</h3>
<p>.. todo:: タイミングチャートの読み方がわからない</p>
<p>先ほどの階層設計を応用して、10 進数 3 桁のカウンタを作り、シミュレータ上で動作を確認します。</p>
<p>D:\Altera\(学籍番号) に vhdl22 というフォルダを作ります。</p>
<p>Web ブラウザで http://vhdl.cottonrose.jp/2016/ を開き、vhdl22.vhd をダウンロードし、先ほどのフォルダにダウンロードします。</p>
<div class="note">
<p>ダウンロードしたファイルが読み取り専用になっていることがあります。</p>
</div>
<p>vhdl11b で使った counter10.vhd も、このフォルダにコピーしておきます。</p>
<p>別冊「Altera開発環境（QuartusII）使用マニュアル」の 21 ページからのシミュレーションの手順を行います。</p>
<p>途中のコンパイルでは **先に counter10.vhd をコンパイル** しておきます。</p>
<p>このソースコードは、そのままでは 10 進数のカウンタが 3 個並び、同じようにカウントするだけになっています。</p>
<p>これを **改造** し、10 進数 3 桁のカウンタにしてください。</p>
<p>ソースコードの抜粋を以下に示します。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">-- COUNTERS ------------------------------------------------------------------

i_counter_0: counter10
  port map (
      gclk0 =&gt; gclk0,
      sw2   =&gt; sw2,
      e_in  =&gt; s_e_in_to_0,
      c_in  =&gt; s_c_in_to_0,
      c_out =&gt; s_c_out_from_0,
      cnt   =&gt; s_cnt_0
  );

i_counter_1: counter10
  port map (
      gclk0 =&gt; gclk0,
      sw2   =&gt; sw2,
      e_in  =&gt; s_e_in_to_1,
      c_in  =&gt; s_c_in_to_1,
      c_out =&gt; s_c_out_from_1,
      cnt   =&gt; s_cnt_1
  );

i_counter_2: counter10
  port map (
      gclk0 =&gt; gclk0,
      sw2   =&gt; sw2,
      e_in  =&gt; s_e_in_to_2,
      c_in  =&gt; s_c_in_to_2,
      c_out =&gt; s_c_out_from_2,
      cnt   =&gt; s_cnt_2
  );

-- edit connection here ------------------------------------------------------

s_e_in_to_0 &lt;= r;
s_c_in_to_0 &lt;= '1';
-- s_c_out_from_0

s_e_in_to_1 &lt;= r;
s_c_in_to_1 &lt;= '1';
-- s_c_out_from_1

s_e_in_to_2 &lt;= r;
s_c_in_to_2 &lt;= '1';
-- s_c_out_from_2

------------------------------------------------------------------------------
</pre>
</div>
<p>ソースコード中の edit connection here にある 9 つの signal の接続を編集することで実現できます。</p>
<p>counter10 の e_in と c_in は、両方に 1 が入力されるとカウントするように働きます。c_out は、カウント値が 9 の時に 1 になります。</p>
<p>counter10 のポートの役割は以下の通りです。</p>
<dl>
<dt>gclk0</dt>
<dd>クロック入力</dd>
<dt>sw2</dt>
<dd>リセット入力</dd>
<dt>e_in</dt>
<dd>カウントしたいタイミングの入力</dd>
<dt>c_in</dt>
<dd>下の桁からの桁上げ信号の入力</dd>
<dt>c_out</dt>
<dd>上の桁への桁上げ信号の出力</dd>
</dl>
<p>3 桁分の counter10 から合計 9 つの signal が引き出されています。</p>
<p>一度シミュレータでこれらの信号の動きを確認し、要求通りの動作をするように、signal の接続を変更してください。</p>
<p>シミュレーション用のコードは判定機能を持っています。</p>
<p>Transcript エリアに &quot;Simulation finished with 0 errors.&quot; と表示されると、正しく動作したと判定されます。</p>
<p>もし数字が 0 でなかったり、&quot;Simulation timed out with *** errors.&quot; (*** は数字 ) と表示されたら、何かしらのエラーがあることになります。</p>

<h2><a id="h5-14"></a><span class="secno">5.14　</span>状態遷移と、条件分岐 case ～ when ～</h2>
<p>例えばカップラーメンを食べようとした場合でも、 (誰かが作ってくれる場合を除いて) 手順があります。</p>
<ol>
<li>カップラーメンの包装をといてふたを開けて小袋をとりだす。必要なものはここで入れる。</li>
<li>やかんに水を入れてコンロにかけて沸かす。</li>
<li>沸騰するのを待つ。</li>
<li>沸騰したら火を止めて、お湯をカップに注ぐ。</li>
<li>３分 (または５分) 待つ。</li>
<li>必要に応じて小袋の中身をカップに入れる。まぜる。</li>
<li>食べてよし。</li>
</ol>
<p>小袋が入ってなかったり電気ポットでお湯を沸かしたり、湯切りタイプだったりとバリエーションがありますが、オーソドックなものではこのように順番があり、例えば１、２は入れ替えたり並列に行ってもいいですが、基本的に手順通りに行います。</p>
<p>プログラミングもこういったところに似ていますが、このように手順通りに処理を行いたい場合、ソフトウェアと同様状態遷移の考え方を使います。</p>
<p>状態遷移は通常は図で状態間のつながりを描きながら設計をし、ソースコードには人間が考えながら書き込むしかありません (図を描くことでソースコードを出力してくれるツールもあります) 。</p>
<p>ソースコード上で、各「状態」を数字で表しながらコーディングすることもできますが、各「状態」に名前をつけて管理しやすくすることができます。</p>
<p>( C 言語の enum と同じような働きです)</p>
<p>使い方はたとえば以下のようになります。</p>
<div class="emlist-code">
<pre class="emlist language-vhdl">type RAMEN is (MAKE_READY_CUP, BOILWATER, POURWATER, WAIT_MINUTES, READY_TO_EAT);
signal ramen_stat : RAMEN;
begin
  ramen_stat &lt;= MAKEREADY;
</pre>
</div>
<p>１行目では RAMEN という型を新しく定義しています。この型のとりうる値は&quot;MAKE_READY_CUP&quot;以降の５種類です。</p>
<p>２行目では、RAMEN の型の signal 、ramen_stat を宣言します。</p>
<p>ramen_stat には MAKE_READY_CUP など、定義した名前を代入したり、if 文で比較したりすることができます。ただし勝手に作った型ですので、そのままでは port から出力しても使えませんし、例えば LED の点灯パターンに対しては全く対応がとれないため使えません。あくまで内部で使うのが基本です。</p>
<p>このようにしなくても、自分でこれらの状態を管理すれば、たとえば integer の signal ででも管理できます。ただしわかりやすい名前をつけることで、ソースコードが理解しやすくなります。</p>

<h2><a id="h5-15"></a><span class="secno">5.15　</span>条件分岐 case ～ when ～</h2>
<div class="note">
<p>case 文は process 文の中でのみ使用できます。</p>
<p>状態遷移専用ではありませんが、case 文はよく組み合わされて使われます。基本的な形は以下の通りです。</p>
</div>
<div class="emlist-code">
<pre class="emlist language-vhdl">case (CONDITION_SIGNAL) is
  when (VALUE_A) =&gt; ～ EXPRESSION A ～
  when (VALUE_B) =&gt; ～ EXPRESSION B ～
  when others =&gt; ～ EXPRESSION OTHER ～
end case;
</pre>
</div>
<p>ある一つの signal の値毎に処理を分岐させることができます。処理は、次の when まで何行でも書くことができます。</p>

<h3><a id="h5-15-1"></a>演習</h3>
<p>スイッチによって、特定の LED を点灯させる回路を作る。* LED1 が点灯している場合、sw2 を操作することで LED1 が消灯し、LED2 が点灯する。* LED2 が点灯している場合、sw1 を操作することで LED2 が消灯し、LED1 が点灯する。sw2 を操作した場合は、LED2 が消灯し、LED3 が点灯する。* LED3 が点灯している場合、sw1 を操作することで LED3 が消灯し、LED2 が点灯する。</p>
<p>swfilter.vhd</p>
<p>.. literalinclude:: sources/swfilter.vhd:language: vhdl</p>
<p>プロジェクト名 vhdl12</p>
<p>vhdl12.vhd</p>
<p>.. literalinclude:: sources/vhdl12.vhd:language: vhdl</p>
<p>case 文とは関係ありませんが、swfilter は sw にスイッチからの信号を接続し、sw out にチャタリング除去後の信号を出力する回路ブロックです。</p>

<h2><a id="h5-16"></a><span class="secno">5.16　</span>ストップウォッチ</h2>
<p>1/100 秒単位のストップウォッチを実装する。</p>
<p>表示は４桁の７セグ LED で行い、１０進数のカウントで、99.99 秒までカウントできること。</p>

<h3><a id="h5-16-1"></a>課題：最小限の構成</h3>
<p>ラップ・スプリット機能の無いストップウォッチを実装する。</p>
<p>操作は２つのスイッチで行う。</p>
<p>スタート・ストップスイッチ往復させる毎にカウント動作とストップを切り替える。</p>
<p>カウント動作中にスタート・ストップスイッチを往復させてストップした後、再度スイッチを往復させると、続きからカウント動作を行う。</p>
<p>リセットスイッチ往復させるとカウントしていた値をクリアする。</p>
<p>カウント動作中にリセットスイッチを往復させた場合の動作は定義しない (どのように動作してもよい) 。</p>
<p>99.99 秒の次のカウントは未定義 (どのように動作してもよい) 。</p>

<h4><a id="h5-16-1-1"></a>ヒント</h4>
<p>vhdl11b に 10 進カウンタ counter10 、7 セグ LED への変換を行う ledconv がひとつずつあって 1 桁の 10 進カウンタができている。vhdl22 の要領で、これを 2 組、3 組、4 組と増やしていき、4 桁の 10 進カウンタを作るのがよい。いきなり 4 桁に挑戦しても躓くことが多い。</p>
<p>1 秒毎にカウントしているので、これを 1/100 毎にカウントするとよい。</p>
<p>スイッチの入力には、vhdl12 のチャタリング除去回路 swfilter が応用できる。</p>
<p>スタート・ストップの切り替えは vhdl10 が応用できる。</p>
<p>今カウント中なのか止まっているのか、判定する signal を作って制御する。ついでにそれを LED に表示するとわかりやすい。</p>
<p>お試しで signal を作るのにためらいは要らない。それを LED に表示しても誰もとがめない。</p>
<p>時々、作った VHDL ファイルを別名でとっておくと良い。内容が把握できなくなったときは、良くない方向に進んでいる可能性が高いので、前の状態からやり直してみる勇気も必要。</p>

<h3><a id="h5-16-2"></a>課題：応用</h3>
<p>ラップ、またはスプリット、または両方の機能のついたストップウォッチを実装する。</p>
<p>操作は２つのスイッチで行う。</p>
<p>スタート・ストップスイッチ往復させる毎にカウント動作とストップを切り替える。</p>
<p>カウント動作中にスタート・ストップスイッチを往復させてストップした後、再度スイッチを往復させた場合、続きからカウント動作を行う。</p>
<p>ラップ/スプリット・リセットスイッチ往復させたときの動作状況に合わせて、このスイッチの動作も変化する。</p>
<p>カウントがストップしている時に往復させるとリセット動作として、カウントしていた値をクリアする。</p>
<p>カウント動作中に往復させるとスプリット状態に移る。表示している値は止めるが、カウント動作は継続する。</p>
<p>スプリット状態で再度往復させると、スプリット状態が解除され、カウントしている値の表示を再開する。</p>
<p>スプリット状態でスタート・ストップスイッチを往復させると、表示している値は維持したまま、カウント動作を止める。</p>
<p>スプリット状態 → カウント停止からこのこのスイッチを往復させると、カウントがストップした値を表示する（スプリット状態が解除される）。</p>
<p>この状態でもう一度このスイッチを往復させると、カウントはクリアする (リセット) その前にスタートのスイッチを往復させると、その値からカウントを再開する。</p>
<p>ラップの場合、ボタンを往復させると表示している値をとめ、カウントは０から再開する。</p>
<p>ラップ機能、スプリット機能を両方実装する場合は、スイッチの一つをモードの切り替えに割り振る。</p>
<p>99.99 秒の次のカウントは00.00 秒とする。</p>

<h4><a id="h5-16-2-1"></a>ヒント</h4>
<p>現在どの状況にいるのかを保持する signal を作り、状態遷移を応用すると良い。</p>
<p>また状況を LED に表示すると良い。</p>

<h3><a id="h5-16-3"></a>その他課題</h3>
<p>タイマを作成する。</p>
<p>表示は、上位２桁が「分」、下位２桁が「秒」とする。</p>
<p>第一段階は、決められた時間 (たとえば３分など) のカウントダウンを行う。０までカウントダウンが完了したらそこで停止する。</p>
<p>リセットするとカウントする時間をリロードする。</p>
<p>第二段階は、カウントする時間を２つから選べるようにする (たとえば３分と５分) 。</p>
<p>最後は、任意の時間を設定できるようにする。</p>
      </div>
      <nav class="book-navi book-prev">
                <a href="04_vhdl.html">
          <div class="book-cursor"><span class="cursor-prev">◀</span></div>
        </a>
              </nav>
      <nav class="book-navi book-next">
                <a href="06_appendix.html">
          <div class="book-cursor"><span class="cursor-next">▶</span></div>
        </a>
              </nav>
    </div>
  </div>
  <footer>
      </footer>
  </body>
</html>
